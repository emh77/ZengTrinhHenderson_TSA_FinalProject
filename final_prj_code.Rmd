---
title: "TSA Final Project"
author: "Angela Zeng, Kristen Trinh, Eliza Henderson"
output:
  html_document:
    df_print: paged
  pdf_document: default
geometry: margin=2.54cm
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,tidy.opts=list(width.cutoff=80), tidy=FALSE) 
```

## Set up
```{r message=FALSE}
#Load libraries 
library(readxl)
library(tidyverse)
library(lubridate)
library(Kendall)
library(tseries)
library(forecast)
library(kableExtra)
library(smooth)
```

##Import and process data 
```{r}
#import dataset 
data_import<- read_excel(path="./ERCOT_annual_generation_data.xlsx",
                sheet="Generation Data",col_names=TRUE)

ppt_data<- data_import[,c(1:3,12:14)] #for show in powerpoint

#extract full years
data_import<- data_import%>%
  filter(Year <= 2022)

#pivot_wider
df<- data_import%>% 
  pivot_wider(names_from = c(Year), values_from = c(Jan, Feb, Mar, Apr,May,Jun,
                                                    Jul, Aug, Sep,Oct, Nov, Dec))
#transpose and fix row and column names 
tdf<- t(df)
df<- as.data.frame(tdf)
rm(tdf)
colnames(df)<- df[1,]
df<- df[2:nrow(df),]
df$date<- rownames(df)
rownames(df)<- NULL

#process date column 
df<- df[,c(ncol(df),1:(ncol(df)-1))]
date<-strsplit(df$date,split="_")
date<-as.data.frame(matrix(unlist(date),ncol=2,byrow=T))
date<- my(paste(date$V1, date$V2))
df$date<- date
rm(date)
df<- df %>% arrange(date)

#fixing the two wind columns 
df$Wind<- ifelse(is.na(df$Wind), df$Wnd, df$Wind)

#fixing the two "other" columns 
df$Other<- ifelse(is.na(df$Other), df$Oth, df$Other)

#convert all numbers to numeric class 
df[,2:ncol(df)] <- apply(df[,2:ncol(df)], 2, as.numeric)

#fixing the gas column 
df$Gas<- ifelse(is.na(df$`Gas-CC`), df$Gas, df$Gas + df$`Gas-CC`)

#convert all numbers to be in the 1000s (new unit: 1000s MWh)
df[,2:ncol(df)] <- df[,2:ncol(df)]/1000

#extract Coal, Gas, Hydro, Nuclear, and Wind columns 
df<- select(df, date, Coal, Gas, Hydro, Nuclear, Wind)

#select data that we will use for forecasting (excludes last year)
df_train<- df %>% filter(year(date) < 2022)

#select data that the forecasts will be tested on 
df_test<- df %>% filter(year(date) == 2022)
```

##Dataset summary 
Add a table that summarizes your data structure (variables, units, ranges and/or central tendencies, data source if multiple are used, etc.). This table should inserted as a `kable` function in an R chunk. Just show the first 10 rows of your data. Do not include the code used to generate your table.
```{r echo=FALSE}
summary<- data.frame(matrix(nrow=0, ncol=5))
min<- apply(df[2:ncol(df)], 2, min)
max<- apply(df[2:ncol(df)], 2, max)
mean<- apply(df[2:ncol(df)], 2, mean)
#can add more summary rows 
df_10<- df[1:10,2:6] #first ten rows of the data 
summary<- rbind(summary, round(min,0), round(max,0), round(mean,0), round(df_10,0))

colnames(summary)<- colnames(df)[2:length(colnames(df))]
Description<- c("min","max","mean",as.character(df[1:10,1]))
summary<- cbind(Description, summary)

kable(summary, 
      caption = "ERCOT Generation (in 1000s MWh)") %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  pack_rows(index = c("Summary of Data" = 3, "Data" = 10))
```


##Visualizing the data 
```{r}
ggplot(df_train) +
  geom_line(aes(x = date, y = `Coal`, color = "Coal")) +
  geom_line(aes(x = date, y = `Gas`, color = "Gas")) +
  geom_line(aes(x = date, y = `Hydro`, color = "Hydro")) +
  geom_line(aes(x = date, y = `Nuclear`, color = "Nuclear")) +
  geom_line(aes(x = date, y = `Wind`, color = "Wind")) +
  scale_color_manual(values = c("Coal" = "#D55E00", "Gas" = "#009E73", 
                                "Hydro" = "#0072B2", "Nuclear"="#F0E442", "Wind"="#CC79A7"))+
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'ERCOT Monthly Generation',
       y='Generation (1000 MWh)',
       x='Year')+
  theme_light()+
  theme(legend.position = "bottom")
```

##Create TS objects and visualize ACF and PACF
```{r}
#create time series object (excludes 2022)
ts_train<- ts(df_train[,(2:6)], frequency = 12, start = c(2008,1))

#time series object for just 2022 
ts_test<- ts(df_test[,(2:6)], frequency = 12, start = c(2022,1))

#plot time series, Acf, and Pacf for TRAINing data
par(mfrow=c(1,3))
for(i in 1:5){
  plot(df_train$date,ts_train[,i],type="l",col="blue",
       ylab="Generation (1000 MWh)",xlab=NA,main=colnames(ts_train)[i])
  acf(ts_train[,i],lag.max=40, plot=TRUE,main=colnames(ts_train)[i])
  pacf(ts_train[,i],lag.max=40, plot=TRUE,main=colnames(ts_train)[i])
}
```

##Working with COAL data
##Can maybe scrap this whole code block
```{r}
#decompose coal data
decompose_coal<- decompose(ts_train[,1], type = "additive")
plot(decompose_coal) 
title(sub = "ERCOT Decomposed Coal Generation", col.sub = "blue")
deseasonal_coal <- seasadj(decompose_coal) #deseasonalized coal 

#Seasonal Mann-Kendall
SMK_coal <- SeasonalMannKendall(ts_train[,1])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_coal))
#p value is < 0.05: reject null hypothesis, data follow a trend

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,1],alternative = "stationary"))
#p value > 0.05 then accept null hypothesis, data has a unit root, i.e., stochastic trend

#coal time series needs to be differenced
ndiffs(ts_train[,1], 0.05, c("kpss", "adf", "pp"), max.d = 2) #only once 

#differencing deseasonalized COAL data
coal_deseas_diff<- diff(x=deseasonal_coal, lag=1, differences=1)
plot(coal_deseas_diff, type="l")

#ACF & PACF for deseasonalized COAL
par(mfrow=c(1,2))
Acf(deseasonal_coal,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Coal Generation")
Pacf(deseasonal_coal,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Coal Generation")

#ACF & PACF for deseasonalized differenced COAL
Acf(coal_deseas_diff,lag.max=40, plot=TRUE, main = "ACF Differenced Decomposed Coal")
Pacf(coal_deseas_diff,lag.max=40, plot=TRUE, main = "PACF Differenced Decomposed Coal")
par(mfrow=c(1,1))

#create df with deseasonalized  and deseasonalized differenced coal
df_coal <- data.frame(date = df_train$date[(2:168)],
                        coal = df_train$Coal[(2:168)],
                        coal_deseas = as.numeric(deseasonal_coal[(2:168)]), 
                        coal_deseas_diff = as.numeric(coal_deseas_diff))

#plot original, differenced, and differenced deseasonalized ts over time 
ggplot(df_coal) +
  geom_line(aes(x = date, y = `coal`, color = "Original Series")) +
  geom_line(aes(x = date, y = `coal_deseas`, color = "Deseasonalized Series")) +
  geom_line(aes(x = date, y = `coal_deseas_diff`, color = "Deseasonalized Differenced Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Deseasonalized Series" = "#E69F00", 
                                "Deseasonalized Differenced Series" = "#0072B2"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Goal Generation',
       y='Generation (1000s MWh)',
       x='Year')

#Model 0: deseasonalized differenced coal ARIMA 
des_diff_coal_arima <- auto.arima(coal_deseas_diff, max.D=0,max.P = 0,max.Q=0)
print(des_diff_coal_arima)
#forecast
des_diff_coal_arima_forecast <- forecast(object = des_diff_coal_arima, h = 12)
plot(des_diff_coal_arima_forecast)

#Model 0: forecast with simple exponential smoothing on differenced coal data
#diff_coal_ses_forecast=ses(y = ts_coal_diff, h = 12, holdout = FALSE, silent = FALSE)  
#checkresiduals(diff_coal_ses_forecast)
#plot(diff_coal_ses_forecast, type="l")
```

##Coal Forecasting 
```{r}
#Model 1: SARIMA
coal_sarima_autofit <- auto.arima(ts_train[,1])
print(coal_sarima_autofit)
#forecast
coal_sarima_forecast <- forecast(object = coal_sarima_autofit, h = 12)
plot(coal_sarima_forecast)

#Model 2: Seasonal SES
coal_sses <- es(ts_train[,1], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(coal_sses)
checkresiduals(coal_sses)

#Model 3: SS with StructTS()
coal_ss_model <- StructTS(ts_train[,1], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(coal_ss_model)
coal_ss_forecast<- forecast(coal_ss_model, h=12)
plot(coal_ss_forecast)
```

##Scores for Coal Forecasts 
```{r}
#test the accuracy of the models 
coal1_scores <- accuracy(coal_sarima_forecast, ts_test[,1], test=NULL)
coal1_scores<- coal1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
coal2_scores <- accuracy(coal_sses$forecast, ts_test[,1], test=NULL)
coal2_scores<- coal2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
coal3_scores <- accuracy(coal_ss_forecast, ts_test[,1], test=NULL)
coal3_scores<- coal3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

coal_scores <- as.data.frame(rbind(coal1_scores[2,], coal2_scores, coal3_scores[2,]))
coal_score_names<- c("sarima","SSES","BSM")
coal_scores<- cbind(coal_score_names, coal_scores)
rm(coal1_scores, coal2_scores, coal3_scores)
print(coal_scores)
```

## Working with GAS Data

##Can probably ignore this block
```{r}
#Seasonal Mann-Kendall
SMK_gas <- SeasonalMannKendall(ts_train[,2])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_gas))
#p value is < 0.05: reject null hypothesis, data follow a trend

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,2],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data does not has a unit root, i.e., stochastic trend

#gas time series needs to be differenced 
ndiffs(ts_train[,2], 0.05, c("kpss", "adf", "pp"), max.d = 2) #once 

#decompose the gas time series 
decompose_gas<- decompose(ts_train[,2], type = "additive")
plot(decompose_gas) 
title(sub = "ERCOT Natural Gas Generation", col.sub = "red")

#deseasonalize the gas time series
deseasonal_gas <- seasadj(decompose_gas) 

#df with og series and deseasonalized series 
df_gas <- data.frame(date = df_train$date,
                        gas = df_train$Gas,
                        deseasonal_gas = as.numeric(deseasonal_gas))

#plot original and deseasonalized ts over time - GGPLOT is not working -K
ggplot(df_gas) +
  geom_line(aes(x = date, y = `gas`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_gas`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Deseasonalized Series" = "#009E73"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Gas Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_gas,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Gas Generation")
Pacf(deseasonal_gas,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Gas Generation")
par(mfrow=c(1,1))

#Model 1: apply auto.arima on deseasonalized data 
#des_gas_arima_autofit <- auto.arima(deseasonal_gas, max.D=0,max.P = 0,max.Q=0)
#print(des_gas_arima_autofit)
#forecast
#des_gas_arima_forecast <- forecast(object = des_gas_arima_autofit, h = 12)
#plot(des_gas_arima_forecast)
```

#Gas Forecasting
```{r}
#Model 1: SARIMA
gas_sarima_autofit <- auto.arima(ts_train[,2])
print(gas_sarima_autofit)
#forecast
gas_sarima_forecast <- forecast(object = gas_sarima_autofit, h = 12)
plot(gas_sarima_forecast)

#Model 2: Seasonal SES
gas_sses <- es(ts_train[,2], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(gas_sses)
checkresiduals(gas_sses)

#Model 3: SS with StructTS()
gas_ss_model <- StructTS(ts_train[,2], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(gas_ss_model)
gas_ss_forecast<- forecast(gas_ss_model, h=12)
plot(gas_ss_forecast)
```

##Scores for Gas Forecasts 
```{r}
#test the accuracy of the models 
gas1_scores <- accuracy(gas_sarima_forecast, ts_test[,2], test=NULL)
gas1_scores<- gas1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
gas2_scores <- accuracy(gas_sses$forecast, ts_test[,2], test=NULL)
gas2_scores<- gas2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
gas3_scores <- accuracy(gas_ss_forecast, ts_test[,2], test=NULL)
gas3_scores<- gas3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]


gas_scores <- as.data.frame(rbind(gas1_scores[2,], gas2_scores, gas3_scores[2,]))
gas_score_names<- c("sarima","SSES","BSM")
gas_scores<- cbind(gas_score_names, gas_scores)
rm(gas1_scores, gas2_scores, gas3_scores)
print(gas_scores)
```

##Hydro 
##Can ignore this whole code block
```{r}
#Seasonal Mann-Kendall
SMK_hydro <- SeasonalMannKendall(ts_train[,3])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_hydro))
#p value is > 0.05: accept null hypothesis, data does not follow a trend 

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,3],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data do not have a unit root, i.e., no stochastic trend
#hydro time series needs NOT need to be differenced
ndiffs(ts_train[,3], 0.05, c("kpss", "adf", "pp"), max.d = 2)

#decompose the hydro time series 
decompose_hydro<- decompose(ts_train[,3], type = "additive")
plot(decompose_hydro) 
title(sub = "ERCOT Hydro Generation", col.sub = "blue")

#deseasonalize the hydro time series
deseasonal_hydro <- seasadj(decompose_hydro) 

#df with og series and deseasonalized series 
df_hydro <- data.frame(date = df_train$date,
                        hydro = df_train$Hydro,
                        deseasonal_hydro = as.numeric(deseasonal_hydro))

#plot original and deseasonalized ts over time 
ggplot(df_hydro) +
  geom_line(aes(x = date, y = `hydro`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_hydro`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Deseasonalized Series" = "#0072B2"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Hydro Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_hydro,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Hydro Generation")
Pacf(deseasonal_hydro,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Hydro Generation")
par(mfrow=c(1,1))

#Model 1: apply auto.arima on deseasonalized data 
des_hydro_arima_autofit <- auto.arima(deseasonal_hydro, max.D=0,max.P = 0,max.Q=0)
print(des_hydro_arima_autofit)
#forecast
des_hydro_arima_forecast <- forecast(object = des_hydro_arima_autofit, h = 12)
plot(des_hydro_arima_forecast)
```

##Hydro Forecasting 
```{r}
#Model 1: SARIMA
hydro_sarima_autofit <- auto.arima(ts_train[,3])
print(hydro_sarima_autofit)
#forecast
hydro_sarima_forecast <- forecast(object = hydro_sarima_autofit, h = 12)
plot(hydro_sarima_forecast)

#Model 2: Seasonal SES
hydro_sses <- es(ts_train[,3], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(hydro_sses)
checkresiduals(hydro_sses)

#Model 3: SS with StructTS()
hydro_ss_model <- StructTS(ts_train[,3], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(hydro_ss_model)
hydro_ss_forecast<- forecast(hydro_ss_model, h=12)
plot(hydro_ss_forecast)
```

##Scores for Hydro Forecasts 
```{r}
#test the accuracy of the models 
hydro1_scores <- accuracy(hydro_sarima_forecast, ts_test[,3], test=NULL)
hydro1_scores<- hydro1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
hydro2_scores <- accuracy(hydro_sses$forecast, ts_test[,3], test=NULL)
hydro2_scores<- hydro2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
hydro3_scores <- accuracy(hydro_ss_forecast, ts_test[,3], test=NULL)
hydro3_scores<- hydro3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

hydro_scores <- as.data.frame(rbind(hydro1_scores[2,], hydro2_scores, hydro3_scores[2,]))
hydro_score_names<- c("sarima","SSES","BSM")
hydro_scores<- cbind(hydro_score_names, hydro_scores)
rm(hydro1_scores, hydro2_scores, hydro3_scores)
print(hydro_scores)
```

##Nuclear
##Can ignore this whole code block 
```{r}
#Seasonal Mann-Kendall
SMK_nuclear <- SeasonalMannKendall(ts_train[,4])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_nuclear))
#p value is > 0.05: accept null hypothesis, data does not follow a trend 

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,4],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data do not have a unit root, i.e., no stochastic trend
#nuclear time series needs NOT need to be differenced
ndiffs(ts_train[,4], 0.05, c("kpss", "adf", "pp"), max.d = 2)

#decompose the nuclear time series 
decompose_nuclear<- decompose(ts_train[,4], type = "additive")
plot(decompose_nuclear) 
title(sub = "ERCOT Nuclear Generation", col.sub = "blue")

#deseasonalize the hydro time series
deseasonal_nuclear <- seasadj(decompose_nuclear) 

#df with og series and deseasonalized series 
df_nuclear <- data.frame(date = df_train$date,
                        nuclear = df_train$Nuclear,
                        deseasonal_nuclear = as.numeric(deseasonal_nuclear))

#plot original and deseasonalized ts over time 
ggplot(df_nuclear) +
  geom_line(aes(x = date, y = `nuclear`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_nuclear`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey", "Deseasonalized Series" = "#F0E442"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Nuclear Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_nuclear,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Nuclear Generation")
Pacf(deseasonal_nuclear,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Nuclear Generation")
par(mfrow=c(1,1))

#Model 1: apply auto.arima on deseasonalized data 
des_nuclear_arima_autofit <- auto.arima(deseasonal_nuclear, max.D=0,max.P = 0,max.Q=0)
print(des_nuclear_arima_autofit)
#forecast
des_nuclear_arima_forecast <- forecast(object = des_nuclear_arima_autofit, h = 12)
plot(des_nuclear_arima_forecast)
```

##Nuclear Forecasting 
```{r}
#Model 1: SARIMA
nuclear_sarima_autofit <- auto.arima(ts_train[,4])
print(nuclear_sarima_autofit)
#forecast
nuclear_sarima_forecast <- forecast(object = nuclear_sarima_autofit, h = 12)
plot(nuclear_sarima_forecast)

#Model 2: Seasonal SES
nuclear_sses <- es(ts_train[,4], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(nuclear_sses)
checkresiduals(nuclear_sses)

#Model 3: SS with StructTS()
nuclear_ss_model <- StructTS(ts_train[,4], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(nuclear_ss_model)
nuclear_ss_forecast<- forecast(nuclear_ss_model, h=12)
plot(nuclear_ss_forecast)
```

##Scores for Nuclear Forecasts 
```{r}
#test the accuracy of the models 
nuclear1_scores <- accuracy(nuclear_sarima_forecast, ts_test[,4], test=NULL)
nuclear1_scores<- nuclear1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
nuclear2_scores <- accuracy(nuclear_sses$forecast, ts_test[,4], test=NULL)
nuclear2_scores<- nuclear2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
nuclear3_scores <- accuracy(nuclear_ss_forecast, ts_test[,4], test=NULL)
nuclear3_scores<- nuclear3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

nuclear_scores <- as.data.frame(rbind(nuclear1_scores[2,], nuclear2_scores, nuclear3_scores[2,]))
nuclear_score_names<- c("sarima","SSES","BSM")
nuclear_scores<- cbind(nuclear_score_names, nuclear_scores)
rm(nuclear1_scores, nuclear2_scores, nuclear3_scores)
print(nuclear_scores)
```

##Wind
##Can ignore this code block 
```{r}
#decompose wind data
decompose_wind<- decompose(ts_train[,5], type = "additive")
plot(decompose_wind) 
title(sub = "ERCOT Decomposed Wind Generation", col.sub = "blue") #can see seasonality and trend
#deseasonalized wind 
deseas_wind <- seasadj(decompose_wind) #deseasonalized wind 

#Seasonal Mann-Kendall
SMK_wind <- SeasonalMannKendall(ts_train[,5])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_wind))
#p value is < 0.05: reject null hypothesis, data do follow a trend 

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,5],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data do not have a unit root, i.e., no stochastic trend

#wind time series needs to be differenced
ndiffs(ts_train[,5], 0.05, c("kpss", "adf", "pp"), max.d = 2) #only once 

#differencing WIND data
wind_diff<- diff(x=df_train[,5], lag=1, differences=1)
plot(wind_diff, type="l")

#create time series object for differenced wind
ts_wind_diff<- ts(wind_diff, frequency = 12, start = c(2008,2))


df_wind <- data.frame(date = df_train$date[(2:168)],
                        wind = df_train$Wind[(2:168)],
                        wind_diff = as.numeric(ts_wind_diff), 
                        wind_diff_deseas = as.numeric(diff_deseas_wind))


#df with og series and deseasonalized series 
df_wind <- data.frame(date = df_train$date,
                        wind = df_train$Wind,
                        diff_wind = as.numeric(ts_wind_diff))

#plot original, differenced, and differenced deseasonalized ts over time 
ggplot(df_wind) +
  geom_line(aes(x = date, y = `wind`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_wind`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey", "Deseasonalized Series" = "#D55E00"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Wind Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_wind,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Wind Generation")
Pacf(deseasonal_wind,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Wind Generation")
par(mfrow=c(1,1))

#plot original, differenced, and differenced deseasonalized ts over time 
ggplot(df_wind) +
  geom_line(aes(x = date, y = `wind`, color = "Original Series")) +
  geom_line(aes(x = date, y = `wind_diff`, color = "Differenced Series")) +
  geom_line(aes(x = date, y = `wind_diff_deseas`, color = "Differenced Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Differenced Series" = "#E69F00", 
                                "Differenced Deseasonalized Series" = "#0072B2"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Wind Generation',
       y='Generation (1000s MWh)',
       x='Year')


#ACF & PACF for differenced WIND
par(mfrow=c(1,2))
Acf(ts_wind_diff,lag.max=40, plot=TRUE, main = "ACF Differenced Wind Generation")
Pacf(ts_wind_diff,lag.max=40, plot=TRUE, main = "PACF Differenced Wind Generation")
par(mfrow=c(1,1))

#ACF & PACF for differenced deseasonalized WIND
par(mfrow=c(1,2))
Acf(diff_deseas_wind,lag.max=40, plot=TRUE, main = "ACF Differenced Deseasonalized Wind Generation")
Pacf(diff_deseas_wind,lag.max=40, plot=TRUE, main = "PACF Differenced Deseasonalized Wind Generation")
par(mfrow=c(1,1))

#Model 1: differenced deseasonalized wind ARIMA
diff_deseas_wind_arima <- auto.arima(diff_deseas_wind, max.D=0,max.P = 0,max.Q=0)
print(diff_deseas_wind_arima)
#forecast
diff_deseas_wind_arima_forecast <- forecast(object = diff_deseas_wind_arima, h = 12)
plot(diff_deseas_wind_arima_forecast)

#Model 2: SARIMA on differenced 
diff_wind_sarima <- auto.arima(ts_wind_diff)
print(diff_wind_sarima)
#forecast
diff_wind_sarima_forecast <- forecast(object = diff_wind_sarima, h = 12)
plot(diff_wind_sarima_forecast)

#Model 3: simple exponential smoothing on differenced wind data
diff_wind_ses_forecast=ses(y = ts_wind_diff, h = 12, holdout = FALSE, silent = FALSE)  
checkresiduals(diff_wind_ses_forecast)
plot(diff_coal_ses_forecast, type="l")

```

##Wind Forecasting 
```{r}
#Model 1: SARIMA
wind_sarima_autofit <- auto.arima(ts_train[,5])
print(wind_sarima_autofit)
#forecast
wind_sarima_forecast <- forecast(object = wind_sarima_autofit, h = 12)
plot(wind_sarima_forecast)

#Model 2: Seasonal SES
wind_sses <- es(ts_train[,5], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(wind_sses)
checkresiduals(wind_sses)

#Model 3: SS with StructTS()
wind_ss_model <- StructTS(ts_train[,5], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(wind_ss_model)
wind_ss_forecast<- forecast(wind_ss_model, h=12)
plot(wind_ss_forecast)
```

##Scores for Wind Forecasts 
```{r}
#test the accuracy of the models 
wind1_scores <- accuracy(wind_sarima_forecast, ts_test[,5], test=NULL)
wind1_scores<- wind1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
wind2_scores <- accuracy(wind_sses$forecast, ts_test[,5], test=NULL)
wind2_scores<- wind2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
wind3_scores <- accuracy(wind_ss_forecast, ts_test[,5], test=NULL)
wind3_scores<- wind3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

wind_scores <- as.data.frame(rbind(wind1_scores[2,], wind2_scores, wind3_scores[2,]))
wind_score_names<- c("sarima","SSES","BSM")
wind_scores<- cbind(wind_score_names, wind_scores)
rm(wind1_scores, wind2_scores, wind3_scores)
print(wind_scores)
```