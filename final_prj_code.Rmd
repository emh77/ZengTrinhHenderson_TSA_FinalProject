---
title: "Forecasting Generation in ERCOT by Fuel Type"
author: "Angela Zeng, Kristen Trinh, Eliza Henderson"
output:
  html_document:
    df_print: paged
  pdf_document: default
geometry: margin=2.54cm
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,tidy.opts=list(width.cutoff=80), tidy=FALSE) 
```


#### Introduction, Motivation, Relevance, Objectives

This project forecasts ERCOT monthly generation by fuel type to analyze energy transition trends. As a leader in renewable energy generation in the United States, ERCOT serves as an example of how development and adoption may play out across the country. Texas has long boasted the highest energy production from renewables due in large part to its strong wind resources and development-friendly business environment and is expected to surpass California in solar in 2023. [1] 

ERCOT serves as an ideal case study due to its depth and breadth of clear, available data. Regulated utilities typically to not publish wide sets of operational data whereas Independent System Operators (ISOs) are required to do so to inform market participation. Furthermore, ERCOT's streamlined market structure is well suited to the auto-regressive nature of this project. Unlike other ISOs, ERCOT does not have a capacity market, thus future capacity buildouts are more directly correlated to energy price signals instead of multiple factors.

A interconnection queue dataset was also included in this study as an optional external factor to include in the model. Queue data identifies planned projects and their progress in interconnection permitting. The dataset captures Feasibility Study status which may be used as a proxy indicator for likelihood of development and timeline of buildout. Projects that have completed this study are more likely to be built and sooner than those who are "not started" or "in-progress." This project ultimately did not integrate queue data as an additional regressor given the structure of available data. Adding a term for it would have required manipulating the data into a time series of matching frequency. The authors felt that the level of modification and extrapolation necessary to convert this data would introduce too much noise into the model.  

#### Dataset Information

All data for this analysis were collected from ERCOT's website. The primary data used detail historical monthly generation by fuel type. Annual excel reports were pulled for the years 2008 to 2022 and aggregated into a single excel document. This document maintained the same formatting structure of the original reports with a column for fuel type and each month (a total of 13). One additional column was added to indicate year. 

The aggregated excel document was loaded into R for further processing. To import and wrangle the data, we used the packages readxl, tidyverse, and lubridate. After importing the data as a new dataframe, it was organized by date according to fuel type. This involved wrangling the data with a pivot_wider function to create a date field with year and month and then transposing the data. After converting the date field to a date values, the data was then further cleaned by aggregating columns of the same fuel type that originally used different naming conventions. For wind this meant combining "wind" and "wnd" columns a a similar process occurred for "other". Starting in 2012, ERCOT began reporting both "Gas" and "Gas-CC" generation values so those were also combined. Next the production values were converted to numeric and then from GWh to MWh. Finally, the dataframe was was converted into a time series with monthly frequency (12) and start date of January 2008 (and an end date of December 2021) for training purposes. The 2022 year was converted into a separate time series with monthly frequency (12) to use for testing forecasts. Solar data was left out as ERCOT only began documenting it separately in 2012.

The second sheet of the aggregated excel file included a summary of February 2023 queue data. This sheet was organized with a row for each fuel type and columns for "Not Started", "In Progress", and "Complete" Feasibility studies. Values reflect MW capacity for each.

 

```{r include=FALSE}
#Needed for some of packages to load properly on Eliza's RStudio container, uncomment as needed
#old.packages <- rownames(installed.packages())[is.na(installed.packages()[, "Priority"])]

# Update all outdated packages
#update.packages(old.packages, ask = FALSE)
```


```{r message=FALSE, warning=FALSE, include=FALSE}
#Load libraries 
library(readxl)
library(tidyverse)
library(lubridate)
library(Kendall)
library(tseries)
library(forecast)
library(kableExtra)
library(smooth)
```


```{r include=FALSE}
#import dataset 
data_import<- read_excel(path="./ERCOT_annual_generation_data.xlsx",
                sheet="Generation Data",col_names=TRUE)

ppt_data<- data_import[,c(1:3,12:14)] #for show in powerpoint

#extract full years
data_import<- data_import%>%
  filter(Year <= 2022)

#pivot_wider
df<- data_import%>% 
  pivot_wider(names_from = c(Year), values_from = c(Jan, Feb, Mar, Apr,May,Jun,
                                                    Jul, Aug, Sep,Oct, Nov, Dec))
#transpose and fix row and column names 
tdf<- t(df)
df<- as.data.frame(tdf)
rm(tdf)
colnames(df)<- df[1,]
df<- df[2:nrow(df),]
df$date<- rownames(df)
rownames(df)<- NULL

#process date column 
df<- df[,c(ncol(df),1:(ncol(df)-1))]
date<-strsplit(df$date,split="_")
date<-as.data.frame(matrix(unlist(date),ncol=2,byrow=T))
date<- my(paste(date$V1, date$V2))
df$date<- date
rm(date)
df<- df %>% arrange(date)

#fixing the two wind columns 
df$Wind<- ifelse(is.na(df$Wind), df$Wnd, df$Wind)

#fixing the two "other" columns 
df$Other<- ifelse(is.na(df$Other), df$Oth, df$Other)

#convert all numbers to numeric class 
df[,2:ncol(df)] <- apply(df[,2:ncol(df)], 2, as.numeric)

#fixing the gas column 
df$Gas<- ifelse(is.na(df$`Gas-CC`), df$Gas, df$Gas + df$`Gas-CC`)

#convert all numbers to be in the 1000s (new unit: 1000s MWh)
df[,2:ncol(df)] <- df[,2:ncol(df)]/1000

#extract Coal, Gas, Hydro, Nuclear, and Wind columns 
df<- select(df, date, Coal, Gas, Hydro, Nuclear, Wind)

#select data that we will use for forecasting (excludes last year)
df_train<- df %>% filter(year(date) < 2022)

#select data that the forecasts will be tested on 
df_test<- df %>% filter(year(date) == 2022)
```

#### Dataset summary 

A summary of the final data is broken down below. This table details the minimum, maximum, and average generation by source as well as the first 10 months of data. We used the function kable from the kableExtra package to generate this table.

```{r echo=FALSE}
summary<- data.frame(matrix(nrow=0, ncol=5))
min<- apply(df[2:ncol(df)], 2, min)
max<- apply(df[2:ncol(df)], 2, max)
mean<- apply(df[2:ncol(df)], 2, mean)
median<- apply(df[2:ncol(df)], 2, median)
sd<- apply(df[2:ncol(df)], 2, sd)
#can add more summary rows 
df_10<- df[1:10,2:6] #first ten rows of the data 
summary<- rbind(summary, round(min,0), round(max,0), round(mean,0), round(median,0), round(sd,0), round(df_10,0))

colnames(summary)<- colnames(df)[2:length(colnames(df))]
Description<- c("min","max","mean","median","standard deviation",as.character(df[1:10,1]))
summary<- cbind(Description, summary)

kable(summary, 
      caption = "Table 1. ERCOT Generation (in 1000s MWh), 2008 - 2022 and first ten rows of data.") %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  pack_rows(index = c("Summary of Data" = 5, "Data" = 10))
```


#### Visualizing the data 

The figure below shows all monthly generation input data by data source using the training data (Year 2008 through 2021). It highlights the upward trend of Wind and Gas generation, stable Hydro and Nuclear production, and the downward trend of Coal. Wind, Gas, and Coal all appear to show annual cycles. Gas and Coal show clear summer peaks with a smaller peak in the winter.

```{r}
ggplot(df_train) +
  geom_line(aes(x = date, y = `Coal`, color = "Coal")) +
  geom_line(aes(x = date, y = `Gas`, color = "Gas")) +
  geom_line(aes(x = date, y = `Hydro`, color = "Hydro")) +
  geom_line(aes(x = date, y = `Nuclear`, color = "Nuclear")) +
  geom_line(aes(x = date, y = `Wind`, color = "Wind")) +
  scale_color_manual(values = c("Coal" = "#D55E00", "Gas" = "#009E73", 
                                "Hydro" = "#0072B2", "Nuclear"="#F0E442", "Wind"="#CC79A7"))+
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'ERCOT Monthly Generation',
       y='Generation (1000 MWh)',
       x='Year')+
  theme_light()+
  theme(legend.position = "bottom")
```

  
*Figure 1. ERCOT monthly generation by fuel type from 2008-2022*



#### Create TS objects and visualize ACF and PACF

We used the package Kendall, tseries, forecast, and smooth for our models and analysis. We created time-series objects for each fuel type. We then ran a Seasonal Mann-Kendall test from the package Kendall. The training data df was then converted to a time series for initial ACF and PACF analysis. The descriptions below summarize results captured in the plots for each source's time series, ACF, and PACF that follow.

**Coal:** The ACF and PACF for coal show characteristics of a seasonal auto-regressive model. The ACF has significant peaks at lag 12, 24, and 36 while the PACF showed a more sudden cut-off.

**Gas:** Gas shows a clear seasonal AR pattern with significant peaks at at lag 12, 24, and 36 and negative correlation at 6, 18, and 30. Though less distinct, the PACF does show a more sudden decline rather than a gradual decay.

**Hydro:** Hydro shows less dramatic seasonality in its ACF and clear autoregressive characteristics in the PACF with a sudden drop-off after lag one.

**Nuclear:** The ACF and PACF of Nuclear demonstrate characteristics of a non-seasonal moving average model. The ACF shows a sudden cut-off whereas the PACF shows more moderate decay.

**Wind:** Wind, like hydro, shows less dramatic seasonality in its ACF but clear autoregressive characteristics with slow decay in the ACF and a sudden drop-off after lag one in the PACF.


```{r include=FALSE}

#create time series object (excludes 2022)
ts_train<- ts(df_train[,(2:6)], frequency = 12, start = c(2008,1))

#time series object for just 2022 
ts_test<- ts(df_test[,(2:6)], frequency = 12, start = c(2022,1))

#plot time series, Acf, and Pacf for TRAINing data
par(mfrow=c(1,3))
for(i in 1:5){
  plot(df_train$date,ts_train[,i],type="l",col="blue",
       ylab="Generation (1000 MWh)",xlab=NA,main=colnames(ts_train)[i])
  acf(ts_train[,i],lag.max=40, plot=TRUE,main=colnames(ts_train)[i])
  pacf(ts_train[,i],lag.max=40, plot=TRUE,main=colnames(ts_train)[i])
}

```

#### Modeling Seasonality and Forecasting Generation

This report captures results for Seasonal ARIMA, Seasonal Exponential Smoothing, and Seasonal State Space models from the forecast library package. Analysis of model performance is broken down by generation source below.

Initial modeling activity also included decomposing the time series for each generation source in order to apply a wider range of models. After deseasoning and differencing the data, the new time series were plotted along with their respective ACF and PACF. These differenced series were then modeled with auto.arima and forecasted accordingly. However, the final set of forecasting models reported here does not use these differenced time series. They instead rely only on the aforementioned models that incorporate seasonality and trend in order to maintain a more apples-to-apples comparison of model performance.

#### Coal
We first analyzed the Coal dataset. We generated and forecasted the three models (SARIMA, SES, StructTS) for the coal data.

```{r message=FALSE, warning=FALSE, include=FALSE}
##Working with COAL data
#decompose coal data
decompose_coal<- decompose(ts_train[,1], type = "additive")
plot(decompose_coal) 
title(sub = "ERCOT Decomposed Coal Generation", col.sub = "blue")
deseasonal_coal <- seasadj(decompose_coal) #deseasonalized coal 

#Seasonal Mann-Kendall
SMK_coal <- SeasonalMannKendall(ts_train[,1])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_coal))
#p value is < 0.05: reject null hypothesis, data follow a trend

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,1],alternative = "stationary"))
#p value > 0.05 then accept null hypothesis, data has a unit root, i.e., stochastic trend

#coal time series needs to be differenced
ndiffs(ts_train[,1], 0.05, c("kpss", "adf", "pp"), max.d = 2) #only once 

#differencing deseasonalized COAL data
coal_deseas_diff<- diff(x=deseasonal_coal, lag=1, differences=1)
plot(coal_deseas_diff, type="l")

#ACF & PACF for deseasonalized COAL
par(mfrow=c(1,2))
Acf(deseasonal_coal,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Coal Generation")
Pacf(deseasonal_coal,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Coal Generation")

#ACF & PACF for deseasonalized differenced COAL
Acf(coal_deseas_diff,lag.max=40, plot=TRUE, main = "ACF Differenced Decomposed Coal")
Pacf(coal_deseas_diff,lag.max=40, plot=TRUE, main = "PACF Differenced Decomposed Coal")
par(mfrow=c(1,1))

#create df with deseasonalized  and deseasonalized differenced coal
df_coal_1 <- data.frame(date = df_train$date[(2:168)],
                        coal = df_train$Coal[(2:168)],
                        coal_deseas = as.numeric(deseasonal_coal[(2:168)]), 
                        coal_deseas_diff = as.numeric(coal_deseas_diff))

#plot original, differenced, and differenced deseasonalized ts over time 
ggplot(df_coal_1) +
  geom_line(aes(x = date, y = `coal`, color = "Original Series")) +
  geom_line(aes(x = date, y = `coal_deseas`, color = "Deseasonalized Series")) +
  geom_line(aes(x = date, y = `coal_deseas_diff`, color = "Deseasonalized Differenced Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Deseasonalized Series" = "#E69F00", 
                                "Deseasonalized Differenced Series" = "#0072B2"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Coal Generation',
       y='Generation (1000s MWh)',
       x='Year')
```

 

#### Coal Forecasting 

The State Space (StructTS) model performs best for coal as shown in the table of accuracy scores. 
The residuals for SES is best but has the worst accuracy scores tied with SARIMA.
```{r echo=FALSE, message=FALSE, warning=FALSE}
#Model 1: SARIMA
coal_sarima_autofit <- auto.arima(ts_train[,1])
#print(coal_sarima_autofit)
coal_sarima_forecast <- forecast(object = coal_sarima_autofit, h = 12)


#Model 2: Seasonal SES
coal_sses <- es(ts_train[,1], model="ZZZ", h= 12, holdout=FALSE, silent=F)
coal_sses_forecast<-forecast(coal_sses, h=12, start=c(2008,1)) #@kristen, we do actually need to keep this
```

  
*Figure 2. Seasonal SES model for Coal.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
#Model 3: SS with StructTS()
coal_ss_model <- StructTS(ts_train[,1], type="BSM",fixed=c(NA,NA,NA,NA)) 
coal_ss_forecast<- forecast(coal_ss_model, h=12)

checkresiduals(coal_sarima_autofit)
```

*Figure 3. Residuals for the ARIMA model for Coal.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
checkresiduals(coal_sses)
```

  
*Figure 4. Residuals for the SSES model for Coal.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
checkresiduals(coal_ss_model, plot=TRUE)
```

  
*Figure 5. Residuals for the StructTS model for Coal.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
#df with test data and forecasts 
df_coal <- data.frame(date = df_test$date,
                      test = df_test$Coal,
                      sarima = coal_sarima_forecast$mean,
                      sses = coal_sses_forecast$mean,
                      bsm = coal_ss_forecast$mean)

#plot all forecasts together against test 
ggplot(df_coal) +
  geom_line(aes(x = date, y = `test`, color = "Original Series")) +
  geom_line(aes(x = date, y = `sarima`, color = "SARIMA")) +
  geom_line(aes(x = date, y = `sses`, color = "SSES")) +
  geom_line(aes(x = date, y = `bsm`, color = "BSM")) +
  scale_color_manual(values = c("Original Series" = "black", "SARIMA" = "blue", "SSES" = "red", "BSM"="green"))+
  theme(legend.position = "right") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       y='Coal Generation (1000s MWh)',
       x='Year')

#ADD CAPTION DESCRIBING THAT THIS IS A FORECAST
```

*Figure 6. 2022 coal generation forecast for each model; the original 2022 data is in black.*  

#### Accuracy Scores for Coal Forecasts 

We then compared the accuracy scores (ME, RMSE, MAE, MPE, and MAPE) for each of the forecasts.

*Table 2. Accuracy scores for models for Coal generation.*
```{r message=FALSE, warning=FALSE}
#test the accuracy of the models 
coal1_scores <- accuracy(coal_sarima_forecast, ts_test[,1], test=NULL)
coal1_scores<- coal1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
coal2_scores <- accuracy(coal_sses$forecast, ts_test[,1], test=NULL)
coal2_scores<- coal2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
coal3_scores <- accuracy(coal_ss_forecast, ts_test[,1], test=NULL)
coal3_scores<- coal3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

coal_scores <- as.data.frame(rbind(coal1_scores[2,], coal2_scores, coal3_scores[2,]))
coal_forecasts<- c("SARIMA","SSES","BSM")
coal_scores<- cbind(coal_forecasts, coal_scores)
rownames(coal_scores)<- c(1:3)
rm(coal1_scores, coal2_scores, coal3_scores)
print(coal_scores)
```

#### Gas

We then analyzed the natural gas dataset. We generated and forecasted the same models for the natural gas data.

```{r message=FALSE, warning=FALSE, include=FALSE}
## Working with GAS Data
#Seasonal Mann-Kendall
SMK_gas <- SeasonalMannKendall(ts_train[,2])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_gas))
#p value is < 0.05: reject null hypothesis, data follow a trend

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,2],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data does not has a unit root, i.e., stochastic trend

#gas time series needs to be differenced 
ndiffs(ts_train[,2], 0.05, c("kpss", "adf", "pp"), max.d = 2) #once 

#decompose the gas time series 
decompose_gas<- decompose(ts_train[,2], type = "additive")
plot(decompose_gas) 
title(sub = "ERCOT Natural Gas Generation", col.sub = "red")

#deseasonalize the gas time series
deseasonal_gas <- seasadj(decompose_gas) 

#df with og series and deseasonalized series 
df_gas <- data.frame(date = df_train$date,
                        gas = df_train$Gas,
                        deseasonal_gas = as.numeric(deseasonal_gas))

#plot original and deseasonalized ts over time - GGPLOT is not working -K
ggplot(df_gas) +
  geom_line(aes(x = date, y = `gas`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_gas`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Deseasonalized Series" = "#009E73"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Gas Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_gas,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Gas Generation")
Pacf(deseasonal_gas,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Gas Generation")
par(mfrow=c(1,1))

#Model 1: apply auto.arima on deseasonalized data 
#des_gas_arima_autofit <- auto.arima(deseasonal_gas, max.D=0,max.P = 0,max.Q=0)
#print(des_gas_arima_autofit)
#forecast
#des_gas_arima_forecast <- forecast(object = des_gas_arima_autofit, h = 12)
#plot(des_gas_arima_forecast)
```

#### Gas Forecasting

The BSM State Space (StructTS) model performs best for gas as shown in the table of accuracy scores. However, the ACF of residuals of the Exponential Smoothing model shows no significant lags, which once again suggests it better captures trends. The ES model also shows more white noise in its residuals and is more normally distributed. 

```{r echo=FALSE, message=FALSE, warning=FALSE}
#Model 1: SARIMA
gas_sarima_autofit <- auto.arima(ts_train[,2])
#print(gas_sarima_autofit)
gas_sarima_forecast <- forecast(object = gas_sarima_autofit, h = 12)

#Model 2: Seasonal SES
gas_sses <- es(ts_train[,2], model="ZZZ", h= 12, holdout=FALSE, silent=F)
gas_sses_forecast<-forecast(gas_sses, h=12, start=c(2008,1))
```

*Figure 7. Seasonal SES Model for Gas generation data.*
```{r echo=FALSE, message=FALSE, warning=FALSE}
#Model 3: SS with StructTS()
gas_ss_model <- StructTS(ts_train[,2], type="BSM",fixed=c(NA,NA,NA,NA)) 
gas_ss_forecast<- forecast(gas_ss_model, h=12)

checkresiduals(gas_sarima_autofit)
```

*Figure 8. Residuals for SARIMA model for Gas generation data.*
```{r echo=FALSE, message=FALSE, warning=FALSE}
checkresiduals(gas_sses)
```

*Figure 9. Residuals for SSES model for Gas generation data.*
```{r echo=FALSE, message=FALSE, warning=FALSE}
checkresiduals(gas_ss_model, plot=TRUE)
```

*Figure 10. Residuals for StructTS model for Gas generation data.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
#df with test data and forecasts 
df_gas <- data.frame(date = df_test$date,
                      test = df_test$Gas,
                      sarima = gas_sarima_forecast$mean,
                      sses = gas_sses_forecast$mean,
                      bsm = gas_ss_forecast$mean)

#plot all forecasts together against test 
ggplot(df_gas) +
  geom_line(aes(x = date, y = `test`, color = "Original Series")) +
  geom_line(aes(x = date, y = `sarima`, color = "SARIMA")) +
  geom_line(aes(x = date, y = `sses`, color = "SSES")) +
  geom_line(aes(x = date, y = `bsm`, color = "BSM")) +
  scale_color_manual(values = c("Original Series" = "black", "SARIMA" = "blue", "SSES" = "red", "BSM"="green"))+
  theme(legend.position = "right") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       y='Gas Generation (1000s MWh)',
       x='Year')

#ADD CAPTION
```

*Figure 11. 2022 gas generation forecast for each model; the original 2022 data is in black.*

#### Scores for Gas Forecasts 

We compared the accuracy scores for the three forecasts to determine which model had the best forecast.

*Table 3. Accuracy scores for models for Gas generation.*
```{r message=FALSE, warning=FALSE}
#test the accuracy of the models 
gas1_scores <- accuracy(gas_sarima_forecast, ts_test[,2], test=NULL)
gas1_scores<- gas1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
gas2_scores <- accuracy(gas_sses$forecast, ts_test[,2], test=NULL)
gas2_scores<- gas2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
gas3_scores <- accuracy(gas_ss_forecast, ts_test[,2], test=NULL)
gas3_scores<- gas3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]


gas_scores <- as.data.frame(rbind(gas1_scores[2,], gas2_scores, gas3_scores[2,]))
gas_forecasts<- c("SARIMA","SSES","BSM")
gas_scores<- cbind(gas_forecasts, gas_scores)
rownames(gas_scores)<- c(1:3)
rm(gas1_scores, gas2_scores, gas3_scores)
print(gas_scores)
```

#### Hydro
Next, we analyzed the hydropower dataset. We generated and forecasted the same models as the previous datasets.

```{r include=FALSE}
#Hydro
#Seasonal Mann-Kendall
SMK_hydro <- SeasonalMannKendall(ts_train[,3])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_hydro))
#p value is > 0.05: accept null hypothesis, data does not follow a trend 

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,3],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data do not have a unit root, i.e., no stochastic trend
#hydro time series needs NOT need to be differenced
ndiffs(ts_train[,3], 0.05, c("kpss", "adf", "pp"), max.d = 2)

#decompose the hydro time series 
decompose_hydro<- decompose(ts_train[,3], type = "additive")
plot(decompose_hydro) 
title(sub = "ERCOT Hydro Generation", col.sub = "blue")

#deseasonalize the hydro time series
deseasonal_hydro <- seasadj(decompose_hydro) 

#df with og series and deseasonalized series 
df_hydro <- data.frame(date = df_train$date,
                        hydro = df_train$Hydro,
                        deseasonal_hydro = as.numeric(deseasonal_hydro))

#plot original and deseasonalized ts over time 
ggplot(df_hydro) +
  geom_line(aes(x = date, y = `hydro`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_hydro`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Deseasonalized Series" = "#0072B2"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Hydro Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_hydro,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Hydro Generation")
Pacf(deseasonal_hydro,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Hydro Generation")
par(mfrow=c(1,1))

#Model 1: apply auto.arima on deseasonalized data 
des_hydro_arima_autofit <- auto.arima(deseasonal_hydro, max.D=0,max.P = 0,max.Q=0)
print(des_hydro_arima_autofit)
#forecast
des_hydro_arima_forecast <- forecast(object = des_hydro_arima_autofit, h = 12)
plot(des_hydro_arima_forecast)
```

#### Hydro Forecasting

The SES model in general performs best for hydro as shown in the table of accuracy scores. 
```{r echo=FALSE, message=FALSE, warning=FALSE}
#Model 1: SARIMA
hydro_sarima_autofit <- auto.arima(ts_train[,3])
#print(hydro_sarima_autofit)
hydro_sarima_forecast <- forecast(object = hydro_sarima_autofit, h = 12)

#Model 2: Seasonal SES
hydro_sses <- es(ts_train[,3], model="ZZZ", h= 12, holdout=FALSE, silent=F)
hydro_sses_forecast<-forecast(hydro_sses, h=12, start=c(2008,1))
```

*Figure 12. Seasonal SES model for hydro generation.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
#Model 3: SS with StructTS()
hydro_ss_model <- StructTS(ts_train[,3], type="BSM",fixed=c(NA,NA,NA,NA)) 
hydro_ss_forecast<- forecast(hydro_ss_model, h=12)

checkresiduals(hydro_sarima_autofit)
```

*Figure 13. Residuals for SARIMA model for hydro generation.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
checkresiduals(hydro_sses, plot=TRUE)
```


*Figure 14. Residuals for SSES model for hydro generation.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
checkresiduals(hydro_ss_model)
```


*Figure 15. Residuals for StructTS model for hydro generation.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
#df with test data and forecasts 
df_hydro <- data.frame(date = df_test$date,
                      test = df_test$Hydro,
                      sarima = hydro_sarima_forecast$mean,
                      sses = hydro_sses_forecast$mean,
                      bsm = hydro_ss_forecast$mean)

#plot all forecasts together against test 
ggplot(df_hydro) +
  geom_line(aes(x = date, y = `test`, color = "Original Series")) +
  geom_line(aes(x = date, y = `sarima`, color = "SARIMA")) +
  geom_line(aes(x = date, y = `sses`, color = "SSES")) +
  geom_line(aes(x = date, y = `bsm`, color = "BSM")) +
  scale_color_manual(values = c("Original Series" = "black", "SARIMA" = "blue", "SSES" = "red", "BSM"="green"))+
  theme(legend.position = "right") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       y='Hydro Generation (1000s MWh)',
       x='Year')

#ADD CAPTION
```


*Figure 16. 2022 hydro generation forecast for each model; the original 2022 data is in black.*

#### Scores for Hydro Forecasts 
We calculated the accuracy scores to confirm which model generated the best forecast for hydro.


*Table 4. Accuracy scores for models for Hydro generation.*
```{r}
#test the accuracy of the models 
hydro1_scores <- accuracy(hydro_sarima_forecast, ts_test[,3], test=NULL)
hydro1_scores<- hydro1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
hydro2_scores <- accuracy(hydro_sses$forecast, ts_test[,3], test=NULL)
hydro2_scores<- hydro2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
hydro3_scores <- accuracy(hydro_ss_forecast, ts_test[,3], test=NULL)
hydro3_scores<- hydro3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

hydro_scores <- as.data.frame(rbind(hydro1_scores[2,], hydro2_scores, hydro3_scores[2,]))
hydro_forecasts<- c("sarima","SSES","BSM")
hydro_scores<- cbind(hydro_forecasts, hydro_scores)
rownames(hydro_scores)<- c(1:3)
rm(hydro1_scores, hydro2_scores, hydro3_scores)
print(hydro_scores)
```

#### Nuclear
Then, we analyzed the nuclear dataset by generating and forecasting the same models as the previous datasets.

```{r include=FALSE}
#Seasonal Mann-Kendall
SMK_nuclear <- SeasonalMannKendall(ts_train[,4])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_nuclear))
#p value is > 0.05: accept null hypothesis, data does not follow a trend 

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,4],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data do not have a unit root, i.e., no stochastic trend
#nuclear time series needs NOT need to be differenced
ndiffs(ts_train[,4], 0.05, c("kpss", "adf", "pp"), max.d = 2)

#decompose the nuclear time series 
decompose_nuclear<- decompose(ts_train[,4], type = "additive")
plot(decompose_nuclear) 
title(sub = "ERCOT Nuclear Generation", col.sub = "blue")

#deseasonalize the hydro time series
deseasonal_nuclear <- seasadj(decompose_nuclear) 

#df with og series and deseasonalized series 
df_nuclear <- data.frame(date = df_train$date,
                        nuclear = df_train$Nuclear,
                        deseasonal_nuclear = as.numeric(deseasonal_nuclear))

#plot original and deseasonalized ts over time 
ggplot(df_nuclear) +
  geom_line(aes(x = date, y = `nuclear`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_nuclear`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey", "Deseasonalized Series" = "#F0E442"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Nuclear Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_nuclear,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Nuclear Generation")
Pacf(deseasonal_nuclear,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Nuclear Generation")
par(mfrow=c(1,1))

#Model 1: apply auto.arima on deseasonalized data 
des_nuclear_arima_autofit <- auto.arima(deseasonal_nuclear, max.D=0,max.P = 0,max.Q=0)
print(des_nuclear_arima_autofit)
#forecast
des_nuclear_arima_forecast <- forecast(object = des_nuclear_arima_autofit, h = 12)
plot(des_nuclear_arima_forecast)
```

#### Nuclear Forecasting 

The SARIMA model performs best for nuclear as shown in the table of accuracy scores. The residuals for all models show a similar number of significant ACF lags and distorted (ie not distinctly normal) histograms suggesting the forecasted models do not capture all of the trends.  

```{r echo=FALSE, message=FALSE, warning=FALSE}
#Model 1: SARIMA
nuclear_sarima_autofit <- auto.arima(ts_train[,4])
#print(nuclear_sarima_autofit)
nuclear_sarima_forecast <- forecast(object = nuclear_sarima_autofit, h = 12)

#Model 2: Seasonal SES
nuclear_sses <- es(ts_train[,4], model="ZZZ", h= 12, holdout=FALSE, silent=F)
nuclear_sses_forecast<-forecast(nuclear_sses, h=12, start=c(2008,1))
```


*Figure 17. Seasonal SES model for nuclear generation.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
#Model 3: SS with StructTS()
nuclear_ss_model <- StructTS(ts_train[,4], type="BSM",fixed=c(NA,NA,NA,NA)) 
nuclear_ss_forecast<- forecast(nuclear_ss_model, h=12)

checkresiduals(nuclear_sarima_autofit)
```



*Figure 18. Residuals for SARIMA model for nuclear generation.*
```{r echo=FALSE, message=FALSE, warning=FALSE}
checkresiduals(nuclear_sses)
```


*Figure 19. Residuals for SSES model for nuclear generation.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
checkresiduals(nuclear_ss_model)
```



*Figure 20. Residuals for StructTS model for nuclear generation.*

```{r echo=FALSE, message=FALSE, warning=FALSE}
#df with test data and forecasts 
df_nuclear <- data.frame(date = df_test$date,
                      test = df_test$Nuclear,
                      sarima = nuclear_sarima_forecast$mean,
                      sses = nuclear_sses_forecast$mean,
                      bsm = nuclear_ss_forecast$mean)

#plot all forecasts together against test 
ggplot(df_nuclear) +
  geom_line(aes(x = date, y = `test`, color = "Original Series")) +
  geom_line(aes(x = date, y = `sarima`, color = "SARIMA")) +
  geom_line(aes(x = date, y = `sses`, color = "SSES")) +
  geom_line(aes(x = date, y = `bsm`, color = "BSM")) +
  scale_color_manual(values = c("Original Series" = "black", "SARIMA" = "blue", "SSES" = "red", "BSM"="green"))+
  theme(legend.position = "right") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       y='Nuclear Generation (1000s MWh)',
       x='Year')

#ADD CAPTION
```

*Figure 21. 2022 nuclear generation forecast for each model; the original 2022 data is in black.*

#### Scores for Nuclear Forecasts 
We checked the accuracy of each forecast to determine which model was the most accurate.


*Table 5. Accuracy scores for models for Nuclear generation.*
```{r echo=FALSE, message=FALSE, warning=FALSE}
#test the accuracy of the models 
nuclear1_scores <- accuracy(nuclear_sarima_forecast, ts_test[,4], test=NULL)
nuclear1_scores<- nuclear1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
nuclear2_scores <- accuracy(nuclear_sses$forecast, ts_test[,4], test=NULL)
nuclear2_scores<- nuclear2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
nuclear3_scores <- accuracy(nuclear_ss_forecast, ts_test[,4], test=NULL)
nuclear3_scores<- nuclear3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

nuclear_scores <- as.data.frame(rbind(nuclear1_scores[2,], nuclear2_scores, nuclear3_scores[2,]))
nuclear_forecasts<- c("sarima","SSES","BSM")
nuclear_scores<- cbind(nuclear_forecasts, nuclear_scores)
rownames(nuclear_scores)<- c(1:3)
rm(nuclear1_scores, nuclear2_scores, nuclear3_scores)
print(nuclear_scores)
```

#### Wind
Lastly, we analyzed the wind dataset by generating and forecasting the same models as the previous datasets.

```{r message=FALSE, warning=FALSE, include=FALSE}
#decompose wind data
decompose_wind<- decompose(ts_train[,5], type = "additive")
plot(decompose_wind) 
title(sub = "ERCOT Decomposed Wind Generation", col.sub = "blue") #can see seasonality and trend
#deseasonalized wind 
deseas_wind <- seasadj(decompose_wind) #deseasonalized wind 

#Seasonal Mann-Kendall
SMK_wind <- SeasonalMannKendall(ts_train[,5])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_wind))
#p value is < 0.05: reject null hypothesis, data do follow a trend 

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,5],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data do not have a unit root, i.e., no stochastic trend

#wind time series needs to be differenced
ndiffs(ts_train[,5], 0.05, c("kpss", "adf", "pp"), max.d = 2) #only once 

#differencing WIND data
wind_diff<- diff(x=df_train[,5], lag=1, differences=1)
plot(wind_diff, type="l")

#create time series object for differenced wind
ts_wind_diff<- ts(wind_diff, frequency = 12, start = c(2008,2))


#df_wind <- data.frame(date = df_train$date[(2:168)],
 #                       wind = df_train$Wind[(2:168)],
  #                      wind_diff = as.numeric(ts_wind_diff), 
   #                     wind_diff_deseas = as.numeric(diff_deseas_wind))


#df with og series and deseasonalized series 
df_wind <- data.frame(date = df_train$date[(2:168)],
                        wind = df_train$Wind[(2:168)],
                        diff_wind = as.numeric(ts_wind_diff))


#plot original, differenced, and differenced deseasonalized ts over time 
#ggplot(df_wind) +
 # geom_line(aes(x = date, y = `wind`, color = "Original Series")) +
  #geom_line(aes(x = date, y = `deseasonal_wind`, color = "Deseasonalized Series")) +
  #scale_color_manual(values = c("Original Series" = "grey", "Deseasonalized Series" = "#D55E00"))+
  #theme_light()+
  #theme(legend.position = "bottom") +
  #scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  #labs(color="",
   #    title = 'Monthly ERCOT Wind Generation',
    #   y='Generation (1000s MWh)',
     #  x='Year')

#ACF & PACF
#par(mfrow=c(1,2))
#Acf(deseasonal_wind,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Wind Generation")
#Pacf(deseasonal_wind,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Wind Generation")
#par(mfrow=c(1,1))

#plot original, differenced, and differenced deseasonalized ts over time 
#ggplot(df_wind) +
 # geom_line(aes(x = date, y = `wind`, color = "Original Series")) +
  #geom_line(aes(x = date, y = `wind_diff`, color = "Differenced Series")) +
  #geom_line(aes(x = date, y = `wind_diff_deseas`, color = "Differenced Deseasonalized Series")) +
  #scale_color_manual(values = c("Original Series" = "grey39", "Differenced Series" = "#E69F00", 
  #                              "Differenced Deseasonalized Series" = "#0072B2"))+
  #theme_light()+
  #theme(legend.position = "bottom") +
  #scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  #labs(color="",
  #     title = 'Monthly ERCOT Wind Generation',
   #    y='Generation (1000s MWh)',
    #   x='Year')


#ACF & PACF for differenced WIND
#par(mfrow=c(1,2))
#Acf(ts_wind_diff,lag.max=40, plot=TRUE, main = "ACF Differenced Wind Generation")
#Pacf(ts_wind_diff,lag.max=40, plot=TRUE, main = "PACF Differenced Wind Generation")
#par(mfrow=c(1,1))

#ACF & PACF for differenced deseasonalized WIND
#par(mfrow=c(1,2))
#Acf(diff_deseas_wind,lag.max=40, plot=TRUE, main = "ACF Differenced Deseasonalized Wind Generation")
#Pacf(diff_deseas_wind,lag.max=40, plot=TRUE, main = "PACF Differenced Deseasonalized Wind Generation")
#par(mfrow=c(1,1))

#Model 1: differenced deseasonalized wind ARIMA
#diff_deseas_wind_arima <- auto.arima(diff_deseas_wind, max.D=0,max.P = 0,max.Q=0)
#print(diff_deseas_wind_arima)
#forecast
#diff_deseas_wind_arima_forecast <- forecast(object = diff_deseas_wind_arima, h = 12)
#plot(diff_deseas_wind_arima_forecast)

#Model 2: SARIMA on differenced 
#diff_wind_sarima <- auto.arima(ts_wind_diff)
#print(diff_wind_sarima)
#forecast
#diff_wind_sarima_forecast <- forecast(object = diff_wind_sarima, h = 12)
#plot(diff_wind_sarima_forecast)

#Model 3: simple exponential smoothing on differenced wind data
#diff_wind_ses_forecast=ses(y = ts_wind_diff, h = 12, holdout = FALSE, silent = FALSE)  
#checkresiduals(diff_wind_ses_forecast)
#plot(diff_coal_ses_forecast, type="l")
```

#### Wind Forecasting 

The SES model in general performs best for wind as shown in the table of accuracy scores. This aligns with the report of residuals, which shows few significant lags in the ACF and normal distribution in the histogram. 

```{r message=FALSE, warning=FALSE}
#Model 1: SARIMA
wind_sarima_autofit <- auto.arima(ts_train[,5])
print(wind_sarima_autofit)
wind_sarima_forecast <- forecast(object = wind_sarima_autofit, h = 12)

#Model 2: Seasonal SES
wind_sses <- es(ts_train[,5], model="ZZZ", h= 12, holdout=FALSE, silent=F)
wind_sses_forecast<-forecast(wind_sses, h=12, start=c(2008,1))

#Model 3: SS with StructTS()
wind_ss_model <- StructTS(ts_train[,5], type="BSM",fixed=c(NA,NA,NA,NA)) 
wind_ss_forecast<- forecast(wind_ss_model, h=12)

checkresiduals(wind_sarima_autofit)
checkresiduals(wind_sses, plot=TRUE)
checkresiduals(wind_ss_model)

#df with test data and forecasts 
df_wind <- data.frame(date = df_test$date,
                      test = df_test$Wind,
                      sarima = wind_sarima_forecast$mean,
                      sses = wind_sses_forecast$mean,
                      bsm = wind_ss_forecast$mean)

#plot all forecasts together against test 
ggplot(df_wind) +
  geom_line(aes(x = date, y = `test`, color = "Original Series")) +
  geom_line(aes(x = date, y = `sarima`, color = "SARIMA")) +
  geom_line(aes(x = date, y = `sses`, color = "SSES")) +
  geom_line(aes(x = date, y = `bsm`, color = "BSM")) +
  scale_color_manual(values = c("Original Series" = "black", "SARIMA" = "blue", "SSES" = "red", "BSM"="green"))+
  theme(legend.position = "right") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       y='Wind Generation (1000s MWh)',
       x='Year')

#ADD CAPTION
```

#### Scores for Wind Forecasts 
We calculated the accuracy scores for each model to determine the best model fit.

```{r}
#test the accuracy of the models 
wind1_scores <- accuracy(wind_sarima_forecast, ts_test[,5], test=NULL)
wind1_scores<- wind1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
wind2_scores <- accuracy(wind_sses$forecast, ts_test[,5], test=NULL)
wind2_scores<- wind2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
wind3_scores <- accuracy(wind_ss_forecast, ts_test[,5], test=NULL)
wind3_scores<- wind3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

wind_scores <- as.data.frame(rbind(wind1_scores[2,], wind2_scores, wind3_scores[2,]))
wind_forecasts<- c("sarima","SSES","BSM")
wind_scores<- cbind(wind_forecasts, wind_scores)
rownames(wind_scores)<- c(1:3)
rm(wind1_scores, wind2_scores, wind3_scores)
print(wind_scores)
```

#### Forecasting 2023 ERCOT generation using the best models 
```{r echo=FALSE, message=FALSE, warning=FALSE}
#best models: Coal: BSM, Gas: BSM, Hydro: SES , Nuclear: SARIMA, Wind: SES

#forecast into the future, training data on full dataset now, df
ts_fulldf<- ts(df[,(2:6)], frequency = 12, start = c(2008,1))

#coal, BSM
coal_2023 <- StructTS(ts_fulldf[,1], type="BSM",fixed=c(NA,NA,NA,NA)) 
coal_2023_forecast<- forecast(coal_2023, h=12)

#gas, BSM
gas_2023 <- StructTS(ts_fulldf[,2], type="BSM",fixed=c(NA,NA,NA,NA)) 
gas_2023_forecast<- forecast(gas_2023, h=12)

#hydro, SES
hydro_2023 <- es(ts_fulldf[,3], model="ZZZ", h= 12, holdout=FALSE, silent=F)
hydro_2023_forecast<-forecast(hydro_2023, h=12, start=c(2008,1))

#nuclear, SARIMA
nuclear_2023 <- auto.arima(ts_fulldf[,4])
print(nuclear_2023)
nuclear_2023_forecast <- forecast(object = nuclear_2023, h = 12)

#wind, SES 
wind_2023 <- es(ts_fulldf[,5], model="ZZZ", h= 12, holdout=FALSE, silent=F)
wind_2023_forecast<-forecast(wind_2023, h=12, start=c(2008,1))

#df with all forecasts 
df_2023_forecast <- data.frame(date = seq(as.Date("2023/01/01"), by = "month", length.out = 12),
                      Coal_f = coal_2023_forecast$mean,
                      Gas_f = gas_2023_forecast$mean,
                      Hydro_f = hydro_2023_forecast$mean,
                      Nuclear_f = nuclear_2023_forecast$mean,
                      Wind_f = wind_2023_forecast$mean)

#combine exisiting data with forecasts 
forecasted_df<- full_join(df, df_2023_forecast)

#PLOT
ggplot(forecasted_df) +
  geom_line(aes(x = date, y = `Coal`, color = "Coal")) +
  geom_line(aes(x = date, y = `Coal_f`, color = "Forecasted Coal")) +
  geom_line(aes(x = date, y = `Gas`, color = "Gas")) +
  geom_line(aes(x = date, y = `Gas_f`, color = "Forecasted Gas")) +
  geom_line(aes(x = date, y = `Hydro`, color = "Hydro")) +
  geom_line(aes(x = date, y = `Hydro_f`, color = "Forecasted Hydro")) +
  geom_line(aes(x = date, y = `Nuclear`, color = "Nuclear")) +
  geom_line(aes(x = date, y = `Nuclear_f`, color = "Forecasted Nuclear")) +
  geom_line(aes(x = date, y = `Wind`, color = "Wind")) +
  geom_line(aes(x = date, y = `Wind_f`, color = "Forecasted Wind")) +
  scale_color_manual(values = c("Coal" = "#D89367","Forecasted Coal" = "#D55E00", 
                                "Gas" = "#7DBA9F" ,"Forecasted Gas" = "#009E73", 
                                "Hydro"="#6F9BC4","Forecasted Hydro" = "#0072B2", 
                                "Nuclear"="#F3EC91","Forecasted Nuclear"="#F0E442", 
                                "Wind"="#D4A4C0","Forecasted Wind"="#CC79A7"))+
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'ERCOT Monthly Generation and Forecasts',
       y='Generation (1000 MWh)',
       x='Year')+
  theme_light()+
  theme(legend.position = "right")

#caption that the darker shades of each color are the forecasted ones 
```


#### Summary and Conclusions

Model performance appeared to correlate with level of seasonality. The State Space model performed best for coal and natural gas, both of which showed clear seasonality and autoregressive characteristics in analyzing their ACF and PACF plots. The Seasonal Exponential Smoothing model performed best for hydro and wind, both of which showed moderate seasonality and autoregressive characteristics in analyzing their ACF and PACF plots. Lastly, the SARIMA model performed best for nuclear, which did not show seasonality and illustrated moving average characteristics in its ACF and PACF plots.

The differences in which models suit which generation source also relate to the use of each fuel. Coal and Gas generation fluctuate to meet demand. These sources therefore produce far more electricity to meet summer air conditioning needs in ERCOT and a minor uptick during the winter holiday season. Hydro and wind, are less easily and non-dispatchable respectively so their generation is less tied to demand and more the operating parameters of each technology. Wind generation is in fact counter-cyclical, with relatively more produced in the winter and less in hotter, summer months. Nuclear operates as baseload power and thus demonstrates its own unique generation pattern of consistent production. Furthermore, nuclear buildout in ERCOT effectively halted prior to the start of collected data, so it does not show any trends caused by changing capacity. 


#### References

[1] Gearino, D. (2023, March 9). One state generates much, much more renewable energy than any other-and it's not California. Inside Climate News. Retrieved April 26, 2023, from https://insideclimatenews.org/news/09032023/inside-clean-energy-texas-renewables/#:~:text=No%2C%20it's%20not%20California.,thanks%20largely%20to%20wind%20energy 

```{r}
df_2023_forecast<- rbind(data.frame(date = df$date, Coal_f = NA, Gas_f = NA, Hydro_f = NA, Nuclear_f = NA, Wind_f = NA), df_2023_forecast)

df<- rbind(df, data.frame(date = seq(as.Date("2023/01/01"), by = "month", length.out = 12), 
           Coal = NA, Gas = NA, Hydro = NA, Nuclear = NA, Wind = NA))
```


