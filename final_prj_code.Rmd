---
title: "TSA Final Project"
author: "Angela Zeng, Kristen Trinh, Eliza Henderson"
output:
  html_document:
    df_print: paged
  pdf_document: default
geometry: margin=2.54cm
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,tidy.opts=list(width.cutoff=80), tidy=FALSE) 
```

#### Introduction, Motivation, Relevance, Objectives

This project forecasts ERCOT monthly generation by fuel type to analyze energy transition trends. As a leader in renewable energy generation in the United States, ERCOT serves as an example of how development and adoption may play out across the country. Texas has long boasted the highest energy production from renewables due in large part to its strong wind resources and development-friendly business environment and is expected to surpass California in solar in 2023 (https://insideclimatenews.org/news/09032023/inside-clean-energy-texas-renewables/#:~:text=No%2C%20it's%20not%20California.,thanks%20largely%20to%20wind%20energy.). 

ERCOT serves as an ideal case study due to its depth and breadth of clear, available data. Regulated utilities typically to not publish wide sets of operational data whereas Independent System Operators (ISOs) are required to do so to inform market participation. Furthermore, ERCOT's streamlined market structure is well suited to the auto-regressive nature of this project. Unlike other ISOs, ERCOT does not have a capacity market, thus future capacity buildouts are more directly correlated to energy price signals instead of multiple factors.

A interconnection queue dataset was also included in this study as an optional external factor to include in the model. Queue data identifies planned projects and their progress in interconnection permitting. The dataset captures Feasibility Study status which may be used as a proxy indicator for likelihood of development and timeline of buildout. Projects that have completed this study are more likely to be built and sooner than those who are "not started" or "in-progress."

#### Dataset Information

All data for this analysis were collected from ERCOT's website. The primary data used detail historical monthly generation by fuel type. Annual excel reports were pulled for the years 2008 to 2022 and aggregated into a single excel document. This document maintained the same formatting structure of the original reports with a column for fuel type and each month (a total of 13). One additional column was added to indicate year.

The aggregated excel document was loaded into r for further processing. After importing the data as a new dataframe, it was organized by date according to fuel type. This involved wrangling the data with a pivot_wider function to create a date field with year and month and then transposing the data. After converting the date field to a date values, the data was then further cleaned by aggregating columns of the same fuel type that originally used different naming conventions. For wind this meant combining "wind" and "wnd" columns a a similar process occured for "other". Starting in 2012, ERCOT began reporting both "Gas" and "Gas-CC" generation values so those were also combined. Next the production values were converted to numeric and then from GWh to MWh. Lastly 2022 data were filtered out of the dataframe and it was converted into a time series with monthly frequency (12) and start date of January 2008. Solar data was left out as ERCOT only began documenting it separately in 2012.

The second sheet of the aggregated excel file included a summary of February 2023 queue data. This sheet was organized with a row for each fuel type and columns for "Not Started", "In Progress", and "Complete" Feasibility studies. Values reflect MW capacity for each.

## Set up
```{r message=FALSE}
#Load libraries 
library(readxl)
library(tidyverse)
library(lubridate)
library(Kendall)
library(tseries)
library(forecast)
library(kableExtra)
library(smooth)
```

##Import and process data 
```{r}
#import dataset 
data_import<- read_excel(path="./ERCOT_annual_generation_data.xlsx",
                sheet="Generation Data",col_names=TRUE)

ppt_data<- data_import[,c(1:3,12:14)] #for show in powerpoint

#extract full years
data_import<- data_import%>%
  filter(Year <= 2022)

#pivot_wider
df<- data_import%>% 
  pivot_wider(names_from = c(Year), values_from = c(Jan, Feb, Mar, Apr,May,Jun,
                                                    Jul, Aug, Sep,Oct, Nov, Dec))
#transpose and fix row and column names 
tdf<- t(df)
df<- as.data.frame(tdf)
rm(tdf)
colnames(df)<- df[1,]
df<- df[2:nrow(df),]
df$date<- rownames(df)
rownames(df)<- NULL

#process date column 
df<- df[,c(ncol(df),1:(ncol(df)-1))]
date<-strsplit(df$date,split="_")
date<-as.data.frame(matrix(unlist(date),ncol=2,byrow=T))
date<- my(paste(date$V1, date$V2))
df$date<- date
rm(date)
df<- df %>% arrange(date)

#fixing the two wind columns 
df$Wind<- ifelse(is.na(df$Wind), df$Wnd, df$Wind)

#fixing the two "other" columns 
df$Other<- ifelse(is.na(df$Other), df$Oth, df$Other)

#convert all numbers to numeric class 
df[,2:ncol(df)] <- apply(df[,2:ncol(df)], 2, as.numeric)

#fixing the gas column 
df$Gas<- ifelse(is.na(df$`Gas-CC`), df$Gas, df$Gas + df$`Gas-CC`)

#convert all numbers to be in the 1000s (new unit: 1000s MWh)
df[,2:ncol(df)] <- df[,2:ncol(df)]/1000

#extract Coal, Gas, Hydro, Nuclear, and Wind columns 
df<- select(df, date, Coal, Gas, Hydro, Nuclear, Wind)

#select data that we will use for forecasting (excludes last year)
df_train<- df %>% filter(year(date) < 2022)

#select data that the forecasts will be tested on 
df_test<- df %>% filter(year(date) == 2022)
```

##Dataset summary 

A summary of the final data is broken down below. This table details the min, max, and average generation by source as well as the first 10 months of data.

```{r echo=FALSE}
summary<- data.frame(matrix(nrow=0, ncol=5))
min<- apply(df[2:ncol(df)], 2, min)
max<- apply(df[2:ncol(df)], 2, max)
mean<- apply(df[2:ncol(df)], 2, mean)
#can add more summary rows 
df_10<- df[1:10,2:6] #first ten rows of the data 
summary<- rbind(summary, round(min,0), round(max,0), round(mean,0), round(df_10,0))

colnames(summary)<- colnames(df)[2:length(colnames(df))]
Description<- c("min","max","mean",as.character(df[1:10,1]))
summary<- cbind(Description, summary)

kable(summary, 
      caption = "ERCOT Generation (in 1000s MWh)") %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  pack_rows(index = c("Summary of Data" = 3, "Data" = 10))
```


##Visualizing the data 

The figure below shows all monthly generation input data by data source using the training data (Year 2008 through 2022). It highlights the upward trend of Wind and Gas generation, stable Hydro and Nuclear production, and the downward trend of Coal. Wind, Gas, and Coal all appear to show annual cycles. Gas and Coal show clear summer peaks with a smaller peak in the winter.

```{r fig.cap = "Monthly Generation by Fuel Source (2008-2022)"}
ggplot(df_train) +
  geom_line(aes(x = date, y = `Coal`, color = "Coal")) +
  geom_line(aes(x = date, y = `Gas`, color = "Gas")) +
  geom_line(aes(x = date, y = `Hydro`, color = "Hydro")) +
  geom_line(aes(x = date, y = `Nuclear`, color = "Nuclear")) +
  geom_line(aes(x = date, y = `Wind`, color = "Wind")) +
  scale_color_manual(values = c("Coal" = "#D55E00", "Gas" = "#009E73", 
                                "Hydro" = "#0072B2", "Nuclear"="#F0E442", "Wind"="#CC79A7"))+
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'ERCOT Monthly Generation',
       y='Generation (1000 MWh)',
       x='Year')+
  theme_light()+
  theme(legend.position = "bottom")
```

##Create TS objects and visualize ACF and PACF

The training data df was then converted to a time series for initial ACF and PACF analysis and preliminary forecasting. The ACF and PACFs for each generation source showed clear indicators of seasonal auto-regressive characteristics for [Coal, Wind, and Gas] with significant ACF values at lag 12, 24, and 36 and and non-seasonal auto-regressive characteristics for [Nuclear and Hydro].

<<Pull from this to describe each appropriately. Per ChatGPT.In a non-seasonal AR process, the ACF will gradually decrease and decay exponentially towards zero, with no significant spikes at any lags. The PACF will have a sharp cut-off after a certain lag, indicating that only the previous few lags are significantly correlated with the current value, and the remaining lags have no significant effect on the current value.

Therefore, the characteristic of a non-seasonal AR process is a gradually decreasing ACF with no significant spikes and a PACF with a sharp cut-off after a certain lag.
The ACF of a seasonal AR process will have significant spikes at multiples of the seasonal lag, indicating the presence of seasonality in the data. The PACF will have similar characteristics as in the non-seasonal case, with a sharp cut-off after a certain lag.

Therefore, the characteristic of a seasonal AR process is a gradually decreasing ACF with significant spikes at multiples of the seasonal lag, and a PACF with a sharp cut-off after a certain lag.
In a non-seasonal MA process, the ACF will have significant spikes at the first few lags and will decay exponentially towards zero as the lag increases. The PACF will gradually decrease and decay towards zero with no significant spikes at any lags.

For a seasonal MA process, the ACF will have significant spikes at multiples of the seasonal lag and will decay towards zero between the spikes. The PACF will have similar characteristics as in the non-seasonal case, with a gradual decrease and decay towards zero.

Therefore, the characteristic of a non-seasonal MA process is a decaying ACF with significant spikes at the first few lags and a PACF that gradually decreases towards zero with no significant spikes at any lags. The characteristic of a seasonal MA process is a decaying ACF with significant spikes at multiples of the seasonal lag and a PACF that gradually decreases towards zero with no significant spikes at any lags.>>

```{r}
#create time series object (excludes 2022)
ts_train<- ts(df_train[,(2:6)], frequency = 12, start = c(2008,1))

#time series object for just 2022 
ts_test<- ts(df_test[,(2:6)], frequency = 12, start = c(2022,1))

#plot time series, Acf, and Pacf for TRAINing data
par(mfrow=c(1,3))
for(i in 1:5){
  plot(df_train$date,ts_train[,i],type="l",col="blue",
       ylab="Generation (1000 MWh)",xlab=NA,main=colnames(ts_train)[i])
  acf(ts_train[,i],lag.max=40, plot=TRUE,main=colnames(ts_train)[i])
  pacf(ts_train[,i],lag.max=40, plot=TRUE,main=colnames(ts_train)[i])
}
```

##Working with COAL data

```{r include=FALSE}
#decompose coal data
decompose_coal<- decompose(ts_train[,1], type = "additive")
plot(decompose_coal) 
title(sub = "ERCOT Decomposed Coal Generation", col.sub = "blue")
deseasonal_coal <- seasadj(decompose_coal) #deseasonalized coal 

#Seasonal Mann-Kendall
SMK_coal <- SeasonalMannKendall(ts_train[,1])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_coal))
#p value is < 0.05: reject null hypothesis, data follow a trend

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,1],alternative = "stationary"))
#p value > 0.05 then accept null hypothesis, data has a unit root, i.e., stochastic trend

#coal time series needs to be differenced
ndiffs(ts_train[,1], 0.05, c("kpss", "adf", "pp"), max.d = 2) #only once 

#differencing deseasonalized COAL data
coal_deseas_diff<- diff(x=deseasonal_coal, lag=1, differences=1)
plot(coal_deseas_diff, type="l")

#ACF & PACF for deseasonalized COAL
par(mfrow=c(1,2))
Acf(deseasonal_coal,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Coal Generation")
Pacf(deseasonal_coal,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Coal Generation")

#ACF & PACF for deseasonalized differenced COAL
Acf(coal_deseas_diff,lag.max=40, plot=TRUE, main = "ACF Differenced Decomposed Coal")
Pacf(coal_deseas_diff,lag.max=40, plot=TRUE, main = "PACF Differenced Decomposed Coal")
par(mfrow=c(1,1))

#create df with deseasonalized  and deseasonalized differenced coal
df_coal <- data.frame(date = df_train$date[(2:168)],
                        coal = df_train$Coal[(2:168)],
                        coal_deseas = as.numeric(deseasonal_coal[(2:168)]), 
                        coal_deseas_diff = as.numeric(coal_deseas_diff))

#plot original, differenced, and differenced deseasonalized ts over time 
ggplot(df_coal) +
  geom_line(aes(x = date, y = `coal`, color = "Original Series")) +
  geom_line(aes(x = date, y = `coal_deseas`, color = "Deseasonalized Series")) +
  geom_line(aes(x = date, y = `coal_deseas_diff`, color = "Deseasonalized Differenced Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Deseasonalized Series" = "#E69F00", 
                                "Deseasonalized Differenced Series" = "#0072B2"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Goal Generation',
       y='Generation (1000s MWh)',
       x='Year')

#Model 0: deseasonalized differenced coal ARIMA 
des_diff_coal_arima <- auto.arima(coal_deseas_diff, max.D=0,max.P = 0,max.Q=0)
print(des_diff_coal_arima)
#forecast
des_diff_coal_arima_forecast <- forecast(object = des_diff_coal_arima, h = 12)
plot(des_diff_coal_arima_forecast)

#Model 0: forecast with simple exponential smoothing on differenced coal data
#diff_coal_ses_forecast=ses(y = ts_coal_diff, h = 12, holdout = FALSE, silent = FALSE)  
#checkresiduals(diff_coal_ses_forecast)
#plot(diff_coal_ses_forecast, type="l")
```

##Coal Forecasting 
```{r}
#Model 1: SARIMA
coal_sarima_autofit <- auto.arima(ts_train[,1])
print(coal_sarima_autofit)
#forecast
coal_sarima_forecast <- forecast(object = coal_sarima_autofit, h = 12)
plot(coal_sarima_forecast)

#Model 2: Seasonal SES
coal_sses <- es(ts_train[,1], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(coal_sses)
checkresiduals(coal_sses)

#Model 3: SS with StructTS()
coal_ss_model <- StructTS(ts_train[,1], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(coal_ss_model)
coal_ss_forecast<- forecast(coal_ss_model, h=12)
plot(coal_ss_forecast)
```

##Scores for Coal Forecasts 
```{r}
#test the accuracy of the models 
coal1_scores <- accuracy(coal_sarima_forecast, ts_test[,1], test=NULL)
coal1_scores<- coal1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
coal2_scores <- accuracy(coal_sses$forecast, ts_test[,1], test=NULL)
coal2_scores<- coal2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
coal3_scores <- accuracy(coal_ss_forecast, ts_test[,1], test=NULL)
coal3_scores<- coal3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

coal_scores <- as.data.frame(rbind(coal1_scores[2,], coal2_scores, coal3_scores[2,]))
coal_score_names<- c("sarima","SSES","BSM")
coal_scores<- cbind(coal_score_names, coal_scores)
rm(coal1_scores, coal2_scores, coal3_scores)
print(coal_scores)
```

## Working with GAS Data

```{r include=FALSE}
#Seasonal Mann-Kendall
SMK_gas <- SeasonalMannKendall(ts_train[,2])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_gas))
#p value is < 0.05: reject null hypothesis, data follow a trend

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,2],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data does not has a unit root, i.e., stochastic trend

#gas time series needs to be differenced 
ndiffs(ts_train[,2], 0.05, c("kpss", "adf", "pp"), max.d = 2) #once 

#decompose the gas time series 
decompose_gas<- decompose(ts_train[,2], type = "additive")
plot(decompose_gas) 
title(sub = "ERCOT Natural Gas Generation", col.sub = "red")

#deseasonalize the gas time series
deseasonal_gas <- seasadj(decompose_gas) 

#df with og series and deseasonalized series 
df_gas <- data.frame(date = df_train$date,
                        gas = df_train$Gas,
                        deseasonal_gas = as.numeric(deseasonal_gas))

#plot original and deseasonalized ts over time - GGPLOT is not working -K
ggplot(df_gas) +
  geom_line(aes(x = date, y = `gas`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_gas`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Deseasonalized Series" = "#009E73"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Gas Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_gas,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Gas Generation")
Pacf(deseasonal_gas,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Gas Generation")
par(mfrow=c(1,1))

#Model 1: apply auto.arima on deseasonalized data 
#des_gas_arima_autofit <- auto.arima(deseasonal_gas, max.D=0,max.P = 0,max.Q=0)
#print(des_gas_arima_autofit)
#forecast
#des_gas_arima_forecast <- forecast(object = des_gas_arima_autofit, h = 12)
#plot(des_gas_arima_forecast)
```

#Gas Forecasting
```{r}
#Model 1: SARIMA
gas_sarima_autofit <- auto.arima(ts_train[,2])
print(gas_sarima_autofit)
#forecast
gas_sarima_forecast <- forecast(object = gas_sarima_autofit, h = 12)
plot(gas_sarima_forecast)

#Model 2: Seasonal SES
gas_sses <- es(ts_train[,2], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(gas_sses)
checkresiduals(gas_sses)

#Model 3: SS with StructTS()
gas_ss_model <- StructTS(ts_train[,2], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(gas_ss_model)
gas_ss_forecast<- forecast(gas_ss_model, h=12)
plot(gas_ss_forecast)
```

##Scores for Gas Forecasts 
```{r}
#test the accuracy of the models 
gas1_scores <- accuracy(gas_sarima_forecast, ts_test[,2], test=NULL)
gas1_scores<- gas1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
gas2_scores <- accuracy(gas_sses$forecast, ts_test[,2], test=NULL)
gas2_scores<- gas2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
gas3_scores <- accuracy(gas_ss_forecast, ts_test[,2], test=NULL)
gas3_scores<- gas3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]


gas_scores <- as.data.frame(rbind(gas1_scores[2,], gas2_scores, gas3_scores[2,]))
gas_score_names<- c("sarima","SSES","BSM")
gas_scores<- cbind(gas_score_names, gas_scores)
rm(gas1_scores, gas2_scores, gas3_scores)
print(gas_scores)
```

##Hydro 
```{r include=FALSE}
#Seasonal Mann-Kendall
SMK_hydro <- SeasonalMannKendall(ts_train[,3])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_hydro))
#p value is > 0.05: accept null hypothesis, data does not follow a trend 

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,3],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data do not have a unit root, i.e., no stochastic trend
#hydro time series needs NOT need to be differenced
ndiffs(ts_train[,3], 0.05, c("kpss", "adf", "pp"), max.d = 2)

#decompose the hydro time series 
decompose_hydro<- decompose(ts_train[,3], type = "additive")
plot(decompose_hydro) 
title(sub = "ERCOT Hydro Generation", col.sub = "blue")

#deseasonalize the hydro time series
deseasonal_hydro <- seasadj(decompose_hydro) 

#df with og series and deseasonalized series 
df_hydro <- data.frame(date = df_train$date,
                        hydro = df_train$Hydro,
                        deseasonal_hydro = as.numeric(deseasonal_hydro))

#plot original and deseasonalized ts over time 
ggplot(df_hydro) +
  geom_line(aes(x = date, y = `hydro`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_hydro`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Deseasonalized Series" = "#0072B2"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Hydro Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_hydro,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Hydro Generation")
Pacf(deseasonal_hydro,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Hydro Generation")
par(mfrow=c(1,1))

#Model 1: apply auto.arima on deseasonalized data 
des_hydro_arima_autofit <- auto.arima(deseasonal_hydro, max.D=0,max.P = 0,max.Q=0)
print(des_hydro_arima_autofit)
#forecast
des_hydro_arima_forecast <- forecast(object = des_hydro_arima_autofit, h = 12)
plot(des_hydro_arima_forecast)
```

##Hydro Forecasting 
```{r}
#Model 1: SARIMA
hydro_sarima_autofit <- auto.arima(ts_train[,3])
print(hydro_sarima_autofit)
#forecast
hydro_sarima_forecast <- forecast(object = hydro_sarima_autofit, h = 12)
plot(hydro_sarima_forecast)

#Model 2: Seasonal SES
hydro_sses <- es(ts_train[,3], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(hydro_sses)
checkresiduals(hydro_sses)

#Model 3: SS with StructTS()
hydro_ss_model <- StructTS(ts_train[,3], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(hydro_ss_model)
hydro_ss_forecast<- forecast(hydro_ss_model, h=12)
plot(hydro_ss_forecast)
```

##Scores for Hydro Forecasts 
```{r}
#test the accuracy of the models 
hydro1_scores <- accuracy(hydro_sarima_forecast, ts_test[,3], test=NULL)
hydro1_scores<- hydro1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
hydro2_scores <- accuracy(hydro_sses$forecast, ts_test[,3], test=NULL)
hydro2_scores<- hydro2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
hydro3_scores <- accuracy(hydro_ss_forecast, ts_test[,3], test=NULL)
hydro3_scores<- hydro3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

hydro_scores <- as.data.frame(rbind(hydro1_scores[2,], hydro2_scores, hydro3_scores[2,]))
hydro_score_names<- c("sarima","SSES","BSM")
hydro_scores<- cbind(hydro_score_names, hydro_scores)
rm(hydro1_scores, hydro2_scores, hydro3_scores)
print(hydro_scores)
```

##Nuclear
```{r include=FALSE}
#Seasonal Mann-Kendall
SMK_nuclear <- SeasonalMannKendall(ts_train[,4])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_nuclear))
#p value is > 0.05: accept null hypothesis, data does not follow a trend 

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,4],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data do not have a unit root, i.e., no stochastic trend
#nuclear time series needs NOT need to be differenced
ndiffs(ts_train[,4], 0.05, c("kpss", "adf", "pp"), max.d = 2)

#decompose the nuclear time series 
decompose_nuclear<- decompose(ts_train[,4], type = "additive")
plot(decompose_nuclear) 
title(sub = "ERCOT Nuclear Generation", col.sub = "blue")

#deseasonalize the hydro time series
deseasonal_nuclear <- seasadj(decompose_nuclear) 

#df with og series and deseasonalized series 
df_nuclear <- data.frame(date = df_train$date,
                        nuclear = df_train$Nuclear,
                        deseasonal_nuclear = as.numeric(deseasonal_nuclear))

#plot original and deseasonalized ts over time 
ggplot(df_nuclear) +
  geom_line(aes(x = date, y = `nuclear`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_nuclear`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey", "Deseasonalized Series" = "#F0E442"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Nuclear Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_nuclear,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Nuclear Generation")
Pacf(deseasonal_nuclear,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Nuclear Generation")
par(mfrow=c(1,1))

#Model 1: apply auto.arima on deseasonalized data 
des_nuclear_arima_autofit <- auto.arima(deseasonal_nuclear, max.D=0,max.P = 0,max.Q=0)
print(des_nuclear_arima_autofit)
#forecast
des_nuclear_arima_forecast <- forecast(object = des_nuclear_arima_autofit, h = 12)
plot(des_nuclear_arima_forecast)
```

##Nuclear Forecasting 
```{r}
#Model 1: SARIMA
nuclear_sarima_autofit <- auto.arima(ts_train[,4])
print(nuclear_sarima_autofit)
#forecast
nuclear_sarima_forecast <- forecast(object = nuclear_sarima_autofit, h = 12)
plot(nuclear_sarima_forecast)

#Model 2: Seasonal SES
nuclear_sses <- es(ts_train[,4], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(nuclear_sses)
checkresiduals(nuclear_sses)

#Model 3: SS with StructTS()
nuclear_ss_model <- StructTS(ts_train[,4], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(nuclear_ss_model)
nuclear_ss_forecast<- forecast(nuclear_ss_model, h=12)
plot(nuclear_ss_forecast)
```

##Scores for Nuclear Forecasts 
```{r}
#test the accuracy of the models 
nuclear1_scores <- accuracy(nuclear_sarima_forecast, ts_test[,4], test=NULL)
nuclear1_scores<- nuclear1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
nuclear2_scores <- accuracy(nuclear_sses$forecast, ts_test[,4], test=NULL)
nuclear2_scores<- nuclear2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
nuclear3_scores <- accuracy(nuclear_ss_forecast, ts_test[,4], test=NULL)
nuclear3_scores<- nuclear3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

nuclear_scores <- as.data.frame(rbind(nuclear1_scores[2,], nuclear2_scores, nuclear3_scores[2,]))
nuclear_score_names<- c("sarima","SSES","BSM")
nuclear_scores<- cbind(nuclear_score_names, nuclear_scores)
rm(nuclear1_scores, nuclear2_scores, nuclear3_scores)
print(nuclear_scores)
```

##Wind
```{r include=FALSE}
#decompose wind data
decompose_wind<- decompose(ts_train[,5], type = "additive")
plot(decompose_wind) 
title(sub = "ERCOT Decomposed Wind Generation", col.sub = "blue") #can see seasonality and trend
#deseasonalized wind 
deseas_wind <- seasadj(decompose_wind) #deseasonalized wind 

#Seasonal Mann-Kendall
SMK_wind <- SeasonalMannKendall(ts_train[,5])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_wind))
#p value is < 0.05: reject null hypothesis, data do follow a trend 

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_train[,5],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data do not have a unit root, i.e., no stochastic trend

#wind time series needs to be differenced
ndiffs(ts_train[,5], 0.05, c("kpss", "adf", "pp"), max.d = 2) #only once 

#differencing WIND data
wind_diff<- diff(x=df_train[,5], lag=1, differences=1)
plot(wind_diff, type="l")

#create time series object for differenced wind
ts_wind_diff<- ts(wind_diff, frequency = 12, start = c(2008,2))


df_wind <- data.frame(date = df_train$date[(2:168)],
                        wind = df_train$Wind[(2:168)],
                        wind_diff = as.numeric(ts_wind_diff), 
                        wind_diff_deseas = as.numeric(diff_deseas_wind))


#df with og series and deseasonalized series 
df_wind <- data.frame(date = df_train$date,
                        wind = df_train$Wind,
                        diff_wind = as.numeric(ts_wind_diff))

#plot original, differenced, and differenced deseasonalized ts over time 
ggplot(df_wind) +
  geom_line(aes(x = date, y = `wind`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_wind`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey", "Deseasonalized Series" = "#D55E00"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Wind Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_wind,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Wind Generation")
Pacf(deseasonal_wind,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Wind Generation")
par(mfrow=c(1,1))

#plot original, differenced, and differenced deseasonalized ts over time 
ggplot(df_wind) +
  geom_line(aes(x = date, y = `wind`, color = "Original Series")) +
  geom_line(aes(x = date, y = `wind_diff`, color = "Differenced Series")) +
  geom_line(aes(x = date, y = `wind_diff_deseas`, color = "Differenced Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey39", "Differenced Series" = "#E69F00", 
                                "Differenced Deseasonalized Series" = "#0072B2"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Wind Generation',
       y='Generation (1000s MWh)',
       x='Year')


#ACF & PACF for differenced WIND
par(mfrow=c(1,2))
Acf(ts_wind_diff,lag.max=40, plot=TRUE, main = "ACF Differenced Wind Generation")
Pacf(ts_wind_diff,lag.max=40, plot=TRUE, main = "PACF Differenced Wind Generation")
par(mfrow=c(1,1))

#ACF & PACF for differenced deseasonalized WIND
par(mfrow=c(1,2))
Acf(diff_deseas_wind,lag.max=40, plot=TRUE, main = "ACF Differenced Deseasonalized Wind Generation")
Pacf(diff_deseas_wind,lag.max=40, plot=TRUE, main = "PACF Differenced Deseasonalized Wind Generation")
par(mfrow=c(1,1))

#Model 1: differenced deseasonalized wind ARIMA
diff_deseas_wind_arima <- auto.arima(diff_deseas_wind, max.D=0,max.P = 0,max.Q=0)
print(diff_deseas_wind_arima)
#forecast
diff_deseas_wind_arima_forecast <- forecast(object = diff_deseas_wind_arima, h = 12)
plot(diff_deseas_wind_arima_forecast)

#Model 2: SARIMA on differenced 
diff_wind_sarima <- auto.arima(ts_wind_diff)
print(diff_wind_sarima)
#forecast
diff_wind_sarima_forecast <- forecast(object = diff_wind_sarima, h = 12)
plot(diff_wind_sarima_forecast)

#Model 3: simple exponential smoothing on differenced wind data
diff_wind_ses_forecast=ses(y = ts_wind_diff, h = 12, holdout = FALSE, silent = FALSE)  
checkresiduals(diff_wind_ses_forecast)
plot(diff_coal_ses_forecast, type="l")

```

##Wind Forecasting 
```{r}
#Model 1: SARIMA
wind_sarima_autofit <- auto.arima(ts_train[,5])
print(wind_sarima_autofit)
#forecast
wind_sarima_forecast <- forecast(object = wind_sarima_autofit, h = 12)
plot(wind_sarima_forecast)

#Model 2: Seasonal SES
wind_sses <- es(ts_train[,5], model="ZZZ", h= 12, holdout=FALSE, silent=F)
plot(wind_sses)
checkresiduals(wind_sses)

#Model 3: SS with StructTS()
wind_ss_model <- StructTS(ts_train[,5], type="BSM",fixed=c(NA,NA,NA,NA)) 
checkresiduals(wind_ss_model)
wind_ss_forecast<- forecast(wind_ss_model, h=12)
plot(wind_ss_forecast)
```

##Scores for Wind Forecasts 
```{r}
#test the accuracy of the models 
wind1_scores <- accuracy(wind_sarima_forecast, ts_test[,5], test=NULL)
wind1_scores<- wind1_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
wind2_scores <- accuracy(wind_sses$forecast, ts_test[,5], test=NULL)
wind2_scores<- wind2_scores[,c("ME","RMSE","MAE","MPE","MAPE")]
wind3_scores <- accuracy(wind_ss_forecast, ts_test[,5], test=NULL)
wind3_scores<- wind3_scores[,c("ME","RMSE","MAE","MPE","MAPE")]

wind_scores <- as.data.frame(rbind(wind1_scores[2,], wind2_scores, wind3_scores[2,]))
wind_score_names<- c("sarima","SSES","BSM")
wind_scores<- cbind(wind_score_names, wind_scores)
rm(wind1_scores, wind2_scores, wind3_scores)
print(wind_scores)
```