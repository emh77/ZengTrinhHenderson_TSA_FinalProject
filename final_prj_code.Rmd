---
title: "TSA Final Project"
author: "Angela Zeng, Kristen Trinh, Eliza Henderson"
output:
  html_document:
    df_print: paged
  pdf_document: default
geometry: margin=2.54cm
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,tidy.opts=list(width.cutoff=80), tidy=FALSE) 
```

## Set up
```{r message=FALSE}
#Load libraries 
library(readxl)
library(tidyverse)
library(lubridate)
library(Kendall)
library(tseries)
library(forecast)
library(kableExtra)
```

##Import and process data 
```{r}
#import dataset 
data_import<- read_excel(path="./ERCOT_annual_generation_data.xlsx",
                sheet="Generation Data",col_names=TRUE)

funzies<- data_import[,c(1:3,12:14)] #for show in powerpoint

#extract full years
data_import<- data_import%>%
  filter(Year <= 2022)

#pivot_wider
df<- data_import%>% 
  pivot_wider(names_from = c(Year), values_from = c(Jan, Feb, Mar, Apr,May,Jun,
                                                    Jul, Aug, Sep,Oct, Nov, Dec))
#transpose and fix row and column names 
tdf<- t(df)
df<- as.data.frame(tdf)
rm(tdf)
colnames(df)<- df[1,]
df<- df[2:nrow(df),]
df$date<- rownames(df)
rownames(df)<- NULL

#process date column 
df<- df[,c(ncol(df),1:(ncol(df)-1))]
date<-strsplit(df$date,split="_")
date<-as.data.frame(matrix(unlist(date),ncol=2,byrow=T))
date<- my(paste(date$V1, date$V2))
df$date<- date
rm(date)
df<- df %>% arrange(date)

#fixing the two wind columns 
df$Wind<- ifelse(is.na(df$Wind), df$Wnd, df$Wind)
df<- subset(df, select=-c(Wnd))

#fixing the two "other" columns 
df$Other<- ifelse(is.na(df$Other), df$Oth, df$Other)
df<- subset(df, select=-c(Oth))

#convert all numbers to numeric class 
df[,2:ncol(df)] <- apply(df[,2:ncol(df)], 2, as.numeric)

#convert all numbers to be in the 1000s (new unit: 1000s MWh)
df[,2:ncol(df)] <- df[,2:ncol(df)]/1000

#extract Coal, Gas, Hydro, Nuclear, and Wind columns 
df<- select(df, date, Coal, Gas, Hydro, Nuclear, Wind)

#select data that we will use for forecasting (excludes last year)
df_short<- df %>% filter(year(date) < 2022)

#select data that the forecasts will be tested on 
df_test<- df %>% filter(year(date) == 2022)
```

##Dataset summary 
Add a table that summarizes your data structure (variables, units, ranges and/or central tendencies, data source if multiple are used, etc.). This table should inserted as a `kable` function in an R chunk. Just show the first 10 rows of your data. Do not include the code used to generate your table.
```{r echo=FALSE}
summary<- data.frame(matrix(nrow=0, ncol=5))
min<- apply(df[2:ncol(df)], 2, min)
max<- apply(df[2:ncol(df)], 2, max)
mean<- apply(df[2:ncol(df)], 2, mean)
#can add more summary rows 
df_10<- df[1:10,2:6] #first ten rows of the data 
summary<- rbind(summary, round(min,0), round(max,0), round(mean,0), round(df_10,0))

colnames(summary)<- colnames(df)[2:length(colnames(df))]
Description<- c("min","max","mean",as.character(df[1:10,1]))
summary<- cbind(Description, summary)

kable(summary, 
      caption = "ERCOT Generation (in 1000s MWh)") %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  pack_rows(index = c("Summary of Data" = 3, "Data" = 10))
```


##Visualizing the data 
```{r}
ggplot(df_short) +
  geom_line(aes(x = date, y = `Coal`, color = "Coal")) +
  geom_line(aes(x = date, y = `Gas`, color = "Gas")) +
  geom_line(aes(x = date, y = `Hydro`, color = "Hydro")) +
  geom_line(aes(x = date, y = `Nuclear`, color = "Nuclear")) +
  geom_line(aes(x = date, y = `Wind`, color = "Wind")) +
  scale_color_manual(values = c("Coal" = "#D55E00", "Gas" = "#009E73", 
                                "Hydro" = "#0072B2", "Nuclear"="#F0E442", "Wind"="#CC79A7"))+
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'ERCOT Monthly Generation',
       y='Generation (1000 MWh)',
       x='Year')+
  theme_light()+
  theme(legend.position = "bottom")
```

##Create TS objects and visualize ACF and PACF
```{r}
#create time series object (excludes 2022)
ts_data<- ts(df_short[,(2:6)], frequency = 12, start = c(2008,1))

#time series object for just 2022 
ts_test<- ts(df_test[,(2:6)], frequency = 12, start = c(2022,1))

#plot time series, Acf, and Pacf
par(mfrow=c(1,3))
for(i in 1:5){
  plot(df_short$date,ts_data[,i],type="l",col="blue",
       ylab="Generation (1000 MWh)",xlab=NA,main=colnames(ts_data)[i])
  acf(ts_data[,i],lag.max=40, plot=TRUE,main=colnames(ts_data)[i])
  pacf(ts_data[,i],lag.max=40, plot=TRUE,main=colnames(ts_data)[i])
}
```

##Working with COAL data
```{r}
#Seasonal Mann-Kendall
SMK_coal <- SeasonalMannKendall(ts_data[,1])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_coal))
#p value is < 0.05: reject null hypothesis, data follow a trend

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_data[,1],alternative = "stationary"))
#p value > 0.05 then accept null hypothesis, data has a unit root, i.e., stochastic trend

#coal time series needs to be differenced
ndiffs(ts_data[,1], 0.05, c("kpss", "adf", "pp"), max.d = 2)
#only once 
#WHEN ARE WE DIFFERENCING? 

#decompose the coal time series 
decompose_coal<- decompose(ts_data[,1], type = "additive")
plot(decompose_coal) 
title(sub = "ERCOT Coal Generation", col.sub = "blue")
#HOW DO WE DECIDE BTW ADDITIVE AND MULTIPLICATIVE?
#from google, additive means the trend is linear (straight line) and multiplicative means there are changes to widiths or heights of seasonal periods over time -k

#deseasonalize the coal time series
deseasonal_coal <- seasadj(decompose_coal) 

#df with og series and deseasonalized series 
df_coal <- data.frame(date = df_short$date,
                        coal = df_short$Coal,
                        deseasonal_coal = as.numeric(deseasonal_coal))

#plot original and deseasonalized ts over time 
ggplot(df_coal) +
  geom_line(aes(x = date, y = `coal`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_coal`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey", "Deseasonalized Series" = "#D55E00"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Goal Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_coal,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Coal Generation")
Pacf(deseasonal_coal,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Coal Generation")
#HOW IS LAG MAX CHOSEN? - I think just vibes -K

#apply auto.arima on deseasonalized data 
des_coal_arima_autofit <- auto.arima(deseasonal_coal, max.D=0,max.P = 0,max.Q=0)
print(des_coal_arima_autofit)

#forecast with auto arima on deseasonalized data 
par(mfrow=c(1,1))
des_coal_arima_forecast <- forecast(object = des_coal_arima_autofit, h = 12)
plot(des_coal_arima_forecast)

#apply auto.arima on original data 
og_coal_arima_autofit <- auto.arima(ts_data[,1])
print(og_coal_arima_autofit)

#forecast with auto arima on original data 
par(mfrow=c(1,1))
og_coal_arima_forecast <- forecast(object = og_coal_arima_autofit, h = 12)
plot(og_coal_arima_forecast)

#forecast with simple exponential smoothing on original data
og_coal_ses_forecast=ses(y = ts_data[,1], h = 12, holdout = FALSE, silent = FALSE)  
checkresiduals(og_coal_ses_forecast)
plot(og_coal_ses_forecast, type="l")
```


```{r}
#differencing COAL data

coal_diff<- diff(x=df_short[,2], lag=1, differences=1)
plot(coal_diff, type="l")

#create df with differenced coal
df_coal_diff <- data.frame(date = df_short$date[(2:168)],
                        coal = df_short$Coal[(2:168)],
                        coal_diff = coal_diff)

#create time series object for differenced coal
ts_coal_diff<- ts(df_coal_diff[,3], frequency = 12, start = c(2008,2))

#do we need to decompose for differenced data?
decompose_coal_diff<- decompose(ts_coal_diff, type = "additive")
plot(decompose_coal_diff) 
title(sub = "ERCOT Differenced Coal Generation", col.sub = "blue")

#ACF & PACF for differenced COAL
par(mfrow=c(1,2))
Acf(ts_coal_diff,lag.max=40, plot=TRUE, main = "ACF Differenced Coal Generation")
Pacf(ts_coal_diff,lag.max=40, plot=TRUE, main = "PACF Differenced Coal Generation")

#differenced coal ARIMA
diff_coal_arima_autofit <- auto.arima(ts_coal_diff, max.D=0,max.P = 0,max.Q=0)
print(diff_coal_arima_autofit)

#forecast with auto arima for differenced coal
par(mfrow=c(1,1))
diff_coal_arima_forecast <- forecast(object = diff_coal_arima_autofit, h = 12)
plot(diff_coal_arima_forecast)

#forecast with simple exponential smoothing on differenced coal data
diff_coal_ses_forecast=ses(y = ts_coal_diff, h = 12, holdout = FALSE, silent = FALSE)  
checkresiduals(diff_coal_ses_forecast)
plot(diff_coal_ses_forecast, type="l")

```

##Scores for Coal Forecasts 
```{r}
#test the accuracy of the models 
coal1_scores <- accuracy(des_coal_arima_forecast, ts_test[,1], test=NULL)
coal1_scores<- coal1_scores[,c("RMSE","MAPE")]
coal2_scores <- accuracy(og_coal_arima_forecast, ts_test[,1], test=NULL)
coal2_scores<- coal2_scores[,c("RMSE","MAPE")]
coal3_scores <- accuracy(og_coal_ses_forecast, ts_test[,1], test=NULL)
coal3_scores<- coal3_scores[,c("RMSE","MAPE")]
coal4_scores <- accuracy(diff_coal_arima_forecast, ts_test[,1], test=NULL)
coal4_scores<- coal4_scores[,c("RMSE","MAPE")]
coal5_scores <- accuracy(diff_coal_ses_forecast, ts_test[,1], test=NULL)
coal5_scores<- coal5_scores[,c("RMSE","MAPE")]

coal_scores <- as.data.frame(rbind(coal1_scores[2,], coal2_scores[2,], coal3_scores[2,], coal4_scores[2,], coal5_scores[2,]))

coal_score_names<- c("arima on deseasonalized","arima on original","SES on original","differenced arima","SES on differenced")

coal_scores<- cbind(coal_score_names, coal_scores)
```



## Working with GAS Data
```{r}

#create df with just data from 2012 to 2022
df_2012_2022<- df_short %>% filter(year(date) > 2011)
ts_data_2012<- ts(df_2012_2022[,(2:6)], frequency = 12, start = c(2012,1))


#Seasonal Mann-Kendall
SMK_gas <- SeasonalMannKendall(ts_data_2012[,2])
print("Results for Seasonal Mann Kendall")
print(summary(SMK_gas))
#p value is < 0.05: reject null hypothesis, data follow a trend

#agumented dickey fuller test (ADF)
#Null hypothesis is that data has a unit root
print("Results for ADF test")
print(adf.test(ts_data_2012[,2],alternative = "stationary"))
#p value < 0.05 then reject null hypothesis, data does not has a unit root, i.e., stochastic trend

#gas time series does NOT need to be differenced
ndiffs(ts_data_2012[,2], 0.05, c("kpss", "adf", "pp"), max.d = 2)


#decompose the gas time series 
decompose_gas<- decompose(ts_data_2012[,2], type = "additive")
plot(decompose_gas) 
title(sub = "ERCOT Natural Gas Generation", col.sub = "red")


#deseasonalize the gas time series
deseasonal_gas <- seasadj(decompose_gas) 

#df with og series and deseasonalized series 
df_gas <- data.frame(date = df_2012_2022$date,
                        gas = df_2012_2022$Gas,
                        deseasonal_gas = as.numeric(deseasonal_gas))

#plot original and deseasonalized ts over time - GGPLOT is not working -K
ggplot(df_gas) +
  geom_line(aes(x = date, y = `gas`, color = "Original Series")) +
  geom_line(aes(x = date, y = `deseasonal_gas`, color = "Deseasonalized Series")) +
  scale_color_manual(values = c("Original Series" = "grey", "Deseasonalized Series" = "#009E73"))+
  theme_light()+
  theme(legend.position = "bottom") +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
  labs(color="",
       title = 'Monthly ERCOT Gas Generation',
       y='Generation (1000s MWh)',
       x='Year')

#ACF & PACF
par(mfrow=c(1,2))
Acf(deseasonal_gas,lag.max=40, plot=TRUE, main = "ACF Deseasonalized Gas Generation")
Pacf(deseasonal_gas,lag.max=40, plot=TRUE, main = "PACF Deseasonalized Gas Generation")


#apply auto.arima on deseasonalized data 
des_gas_arima_autofit <- auto.arima(deseasonal_gas, max.D=0,max.P = 0,max.Q=0)
print(des_gas_arima_autofit)

#forecast with auto arima on deseasonalized data 
par(mfrow=c(1,1))
des_gas_arima_forecast <- forecast(object = des_gas_arima_autofit, h = 12)
plot(des_gas_arima_forecast)

#apply auto.arima on original data 
og_gas_arima_autofit <- auto.arima(ts_data_2012[,2])
print(og_gas_arima_autofit)

#forecast with auto arima on original data 
par(mfrow=c(1,1))
og_gas_arima_forecast <- forecast(object = og_gas_arima_autofit, h = 12)
plot(og_gas_arima_forecast)

#forecast with simple exponential smoothing on original data
og_gas_ses_forecast=ses(y = ts_data_2012[,2], h = 12, holdout = FALSE, silent = FALSE)  
checkresiduals(og_gas_ses_forecast)
plot(og_gas_ses_forecast, type="l")

```

##Scores for Gas Forecasts 
```{r}
#test the accuracy of the models 
#SOMETHING IS WRONG HERE SIGH
gas1_scores <- accuracy(des_gas_arima_autofit, ts_test[,2], test=NULL)
gas1_scores<- gas1_scores[,c("RMSE","MAPE")]
gas2_scores <- accuracy(og_gas_arima_forecast, ts_test[,2], test=NULL)
gas2_scores<- gas2_scores[,c("RMSE","MAPE")]
gas3_scores <- accuracy(og_gas_ses_forecast, ts_test[,2], test=NULL)
gas3_scores<- gas3_scores[,c("RMSE","MAPE")]

gas_scores <- as.data.frame(rbind(gas1_scores[2,], gas2_scores[2,], gas3_scores[2,]))
gas_score_names<- c("arima on deseasonalized","arima on original","SES on original")
gas_scores<- cbind(gas_score_names, gas_scores)

```

